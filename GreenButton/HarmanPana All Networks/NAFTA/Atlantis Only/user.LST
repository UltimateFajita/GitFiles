C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USER
OBJECT MODULE PLACED IN user.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe user.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          //Can Bus Simulator
   2          #include "c8051F040.h"
   3          #include "stdlib.h"
   4          #include "string.h"
   5          #include "stdio.h"
   6          #include "main.h"
   7          #include "spi.h"
   8          
   9          extern CANFRAME xdata OneTime[TXBUFFS];
  10          extern CANFRAME xdata rxframe0[RX0BUFFERS];
  11          extern U8 xdata MaxMesgs,MaxRxTraps;
  12          
  13          extern MSGTABLE xdata *Mesgs;
  14          extern U8 xdata MesgCnt;
  15          extern BUTTABLE xdata *Buttons;
  16          extern U8 xdata ButtCnt;
  17          extern RxMESG xdata *RxMesg;
  18          extern U8 xdata RxCnt;
  19          extern U16 xdata RelayCnf[4];
  20          extern U8 xdata RelayChange;
  21          extern U8 xdata RxBuffCnt[2];
  22          
  23          extern bit IGN_OFF_FLG;
  24          
  25          extern U32 keys,keyChange;
  26          extern bit RxCAN0,RxCAN1;
  27          extern U32 msticks;
  28          
  29          void User1()    // program select 3
  30          {       
  31   1      
  32   1              xdata U32 StartTicks = 0;
  33   1              U8 index,index1,error,ErrCnt,counter,cnt,vin;
  34   1              bit IGN_OFF=1;
  35   1      
  36   1              char VIN[17] = "2C3CCABT6GH100096";
  37   1      //      char VIN[17] = "12345678281234567";
  38   1      
  39   1              error = 0;      ErrCnt=0;
  40   1      
  41   1      /***************************************************************************************
  42   1      ****************************************************************************************
  43   1              CAUTION WATCH XDATA BOUNDARIES.  NOT AUTOMATIC ITS UP TO YOU!!!!!!
  44   1      ****************************************************************************************
  45   1              // CODE CURRENTLY USES 809 xdata bytes.  THEREFORE STARTING CAN BE AT 0x32A
  46   1              // watch at compile the xdata bytes used. if xdata > 810d need to change below
  47   1              // xdata space ends at 0xFFF.
  48   1      ***************************************************************************************/
  49   1      //      Buttons = (BUTTABLE xdata *)0x32A;      // 20 buttons takes 32Abytes => 0x32A-0x4E1
  50   1              ButtCnt = 0;                                            // each Button = 20 bytes
  51   1      
  52   1      //      Mesgs = (MSGTABLE xdata *)0x4E2;        // 0x4E2-0x93F -> space for 43 Tx messages 
  53   1              MesgCnt = 0;                                            // each Mesgs = 26 bytes
  54   1      
  55   1      //      RxMesg = (RxMESG xdata *)0x940;         // 0x940-0xFF8 -> space for 43 Rx messages 
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 2   

  56   1              RxCnt = 0;                                                      // each RxMesg = 40 bytes
  57   1      
  58   1      // AUTOMATED above some,
  59   1      // Make Sure XDATASPACE define follows compile output value  
  60   1      #define XDATASPACE 810          // starting free address
  61   1      
  62   1      /****************************************************************************************
  63   1      // Currently (809 xdata start) you get 43 Tx messages and 43 Rx message traps.  If you 
  64   1      // need more of one and less of the other you can manipulate the starting numbers below
  65   1      // to get it to work.
  66   1      // also note RX0 buff size is 32 messages on CAN0, and RX1 buff size is 16 for CAN1
  67   1      ***************************************************************************************/
  68   1              MaxMesgs = 45;                  // number of Tx message configs
  69   1              MaxRxTraps = 45;                // number of Rx message configs
  70   1              while(!MemManage(MAXBUTTONS,MaxMesgs,MaxRxTraps,XDATASPACE))    // 20 button configs  
  71   1              {
  72   2                      MaxRxTraps--;           // reduce Message buffers till it fits.
  73   2                      if (!MemManage(MAXBUTTONS,MaxMesgs,MaxRxTraps,XDATASPACE))
  74   2                              MaxMesgs--;             // reduce Message buffers till it fits
  75   2              }
  76   1      /**************************************************************************************/
  77   1      
  78   1      
  79   1      /*************************************************************************
  80   1              Repeating message setups
  81   1              example below-
  82   1              message ID 0x6E2 is created at rate of 500mSec on port 1 (C). With 8 bytes 
  83   1              of data, shown are it's defaults.
  84   1      **************************************************************************/
  85   1      
  86   1      
  87   1      /*      /// IPC_DISPLAY_INFO
  88   1              OneTime[0].cdat[0] = 0;
  89   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
  90   1              OneTime[0].cdat[2] = 0;
  91   1              OneTime[0].sz = 3;
  92   1              OneTime[0].arbID = 0x092 | 0;
  93   1      //      AddMessage(0,0x092,100,3,OneTime[0].cdat) */
  94   1      
  95   1      /*      /// U_CONN_REQ - ETM
  96   1              OneTime[0].cdat[0] = 0;
  97   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
  98   1              OneTime[0].cdat[2] = 0;
  99   1              OneTime[0].cdat[3] = 0;
 100   1              OneTime[0].cdat[4] = 0;
 101   1              AddMessage(0,0x2EC,1000,5,OneTime[0].cdat); */
 102   1      
 103   1              /// SWC
 104   1      /*      OneTime[0].cdat[0] = 0;
 105   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 106   1              OneTime[0].cdat[2] = 0;
 107   1              OneTime[0].cdat[3] = 0;
 108   1              OneTime[0].sz = 4;
 109   1              OneTime[0].arbID = 0x2EE | 0;
 110   1      //      AddMessage(0,0x2EE,500,4,OneTime[0].cdat); */
 111   1              OneTime[0].cdat[0] = 0;
 112   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 113   1              OneTime[0].cdat[2] = 0;
 114   1              OneTime[0].cdat[3] = 0;
 115   1              AddMessage(0,0x2EE,250,4,OneTime[0].cdat); 
 116   1      
 117   1              /// STATUS_BH_BCM1
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 3   

 118   1              OneTime[0].cdat[0] = 0;
 119   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 120   1              OneTime[0].cdat[2] = 0x20;
 121   1              OneTime[0].cdat[3] = 0;
 122   1              OneTime[0].cdat[4] = 0;
 123   1              OneTime[0].cdat[5] = 0;
 124   1              OneTime[0].cdat[6] = 0;
 125   1              OneTime[0].cdat[7] = 0;
 126   1              AddMessage(0,0x356,250,8,OneTime[0].cdat);
 127   1      //      AddMessage(0,0x356,1000,8,OneTime[0].cdat);
 128   1      
 129   1      /*
 130   1      /// SDW_INFO
 131   1              OneTime[0].cdat[0] = 0;
 132   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 133   1              OneTime[0].cdat[2] = 0;
 134   1              OneTime[0].cdat[3] = 0;
 135   1              OneTime[0].cdat[4] = 0;
 136   1              OneTime[0].cdat[5] = 0;
 137   1              OneTime[0].sz = 6;
 138   1              OneTime[0].arbID = 0x3B4 | 0;
 139   1      
 140   1      //      AddMessage(0,0x3B4,20000,6,OneTime[0].cdat); 
 141   1      
 142   1              /// PARK_INFO
 143   1              OneTime[0].cdat[0] = 0;
 144   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 145   1              OneTime[0].cdat[2] = 0;
 146   1              OneTime[0].cdat[3] = 0;
 147   1              OneTime[0].cdat[4] = 0;
 148   1              OneTime[0].cdat[5] = 0;
 149   1              OneTime[0].sz = 6;
 150   1              OneTime[0].arbID = 0x3B6 | 0;
 151   1      //      AddMessage(0,0x3B6,20000,6,OneTime[0].cdat); 
 152   1              
 153   1      */
 154   1      /*      /// IPC_ACK
 155   1              OneTime[0].cdat[0] = 89;
 156   1              OneTime[0].sz = 1;
 157   1              OneTime[0].arbID = 0x3DA | 0; */
 158   1      
 159   1              /// STATUS_CCAN1
 160   1              OneTime[0].cdat[0] = 0;
 161   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 162   1              OneTime[0].cdat[2] = 0;
 163   1              OneTime[0].cdat[3] = 0;
 164   1              OneTime[0].cdat[4] = 0;
 165   1              OneTime[0].cdat[5] = 0;
 166   1              OneTime[0].cdat[6] = 0;
 167   1              AddMessage(0,0x3DC,100,7,OneTime[0].cdat);
 168   1      
 169   1              /// STATUS_CCAN2
 170   1              OneTime[0].cdat[0] = 0x3E;
 171   1              OneTime[0].cdat[1] = 0x1E;      // using OneTime structure as temp storage
 172   1              OneTime[0].cdat[2] = 0x1E;
 173   1              OneTime[0].cdat[3] = 0;
 174   1              OneTime[0].cdat[4] = 0x03;
 175   1              OneTime[0].cdat[5] = 0x01;
 176   1              OneTime[0].cdat[6] = 0x91;
 177   1              OneTime[0].cdat[7] = 0x01;
 178   1              AddMessage(0,0x3DE,100,8,OneTime[0].cdat);
 179   1      
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 4   

 180   1              /// VIN
 181   1              vin = 0;
 182   1              OneTime[0].cdat[0] = 0;
 183   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 184   1              OneTime[0].cdat[2] = 0;
 185   1              OneTime[0].cdat[3] = 0;
 186   1              OneTime[0].cdat[4] = 0;
 187   1              OneTime[0].cdat[5] = 0;
 188   1              OneTime[0].cdat[6] = 0;
 189   1              OneTime[0].cdat[7] = 0;
 190   1      //      AddMessage(0,0x3E0,100,8,OneTime[0].cdat);
 191   1              AddMessage(0,0x3E0,1000,8,OneTime[0].cdat);
 192   1      
 193   1      /*      /// STATUS_CCAN3
 194   1              OneTime[0].cdat[0] = 0;
 195   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 196   1              OneTime[0].cdat[2] = 0x04;
 197   1              OneTime[0].cdat[3] = 0;
 198   1              OneTime[0].cdat[4] = 0x3C;
 199   1              OneTime[0].cdat[5] = 0;
 200   1              OneTime[0].cdat[6] = 0x03;
 201   1              OneTime[0].cdat[7] = 0;
 202   1              AddMessage(0,0x3E2,100,8,OneTime[0].cdat); */
 203   1              OneTime[0].cdat[0] = 0;
 204   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 205   1              OneTime[0].cdat[2] = 0;
 206   1              OneTime[0].cdat[3] = 0;
 207   1              OneTime[0].cdat[4] = 0;
 208   1              OneTime[0].cdat[5] = 0;
 209   1              OneTime[0].cdat[6] = 0;
 210   1              OneTime[0].cdat[7] = 0x02;
 211   1              AddMessage(0,0x3E2,100,8,OneTime[0].cdat);
 212   1      
 213   1              /// STATUS_CCAN4
 214   1              OneTime[0].cdat[0] = 0x89;
 215   1              OneTime[0].cdat[1] = 0xDA;      // using OneTime structure as temp storage
 216   1              OneTime[0].cdat[2] = 0x98;
 217   1              OneTime[0].cdat[3] = 0x06;
 218   1              OneTime[0].cdat[4] = 0;
 219   1              OneTime[0].cdat[5] = 0;
 220   1              OneTime[0].cdat[6] = 0;
 221   1              OneTime[0].cdat[7] = 0;
 222   1              AddMessage(0,0x3E4,100,8,OneTime[0].cdat);
 223   1      
 224   1              /// STATUS_CCAN5
 225   1              OneTime[0].cdat[0] = 0;
 226   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 227   1              OneTime[0].cdat[2] = 0;
 228   1              OneTime[0].cdat[3] = 0;
 229   1              OneTime[0].cdat[4] = 0;
 230   1              OneTime[0].cdat[5] = 0;
 231   1              OneTime[0].cdat[6] = 0;
 232   1      //      OneTime[0].cdat[7] = 0;
 233   1              OneTime[0].cdat[7] = 0x02;
 234   1      //      AddMessage(0,0x3E6,1000,8,OneTime[0].cdat);
 235   1              AddMessage(0,0x3E6,100,8,OneTime[0].cdat);
 236   1      
 237   1              /// CLIMATIC_PANEL
 238   1              OneTime[0].cdat[0] = 0;
 239   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 240   1              OneTime[0].cdat[2] = 0;
 241   1              OneTime[0].cdat[3] = 0;
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 5   

 242   1              OneTime[0].cdat[4] = 0;
 243   1              OneTime[0].cdat[5] = 0;
 244   1              OneTime[0].cdat[6] = 0;
 245   1              OneTime[0].cdat[7] = 0;
 246   1              AddMessage(0,0x41A,1000,8,OneTime[0].cdat);
 247   1      
 248   1      /*      /// STATUS_BH_IPC
 249   1              OneTime[0].cdat[0] = 0;
 250   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 251   1              AddMessage(0,0x468,500,8,OneTime[0].cdat); */
 252   1      
 253   1              /// STATUS_BH_BCM2
 254   1      /*      OneTime[0].cdat[0] = 0;
 255   1              OneTime[0].cdat[1] = 0x80;      // using OneTime structure as temp storage
 256   1              OneTime[0].cdat[2] = 0xFF;
 257   1              OneTime[0].cdat[3] = 0xFF;
 258   1              OneTime[0].cdat[4] = 0xC0;
 259   1              OneTime[0].cdat[5] = 0x14;
 260   1              OneTime[0].cdat[6] = 0;
 261   1              OneTime[0].cdat[7] = 0;
 262   1              AddMessage(0,0x46C,500,8,OneTime[0].cdat); */
 263   1              OneTime[0].cdat[0] = 0;
 264   1              OneTime[0].cdat[1] = 0x20;      // using OneTime structure as temp storage
 265   1              OneTime[0].cdat[2] = 0x69;
 266   1              OneTime[0].cdat[3] = 0x2F;
 267   1              OneTime[0].cdat[4] = 0;
 268   1              OneTime[0].cdat[5] = 0;
 269   1              OneTime[0].cdat[6] = 0;
 270   1              OneTime[0].cdat[7] = 0x02;
 271   1              AddMessage(0,0x46C,1000,8,OneTime[0].cdat);
 272   1      
 273   1      /*      /// HAPTIC1
 274   1              OneTime[0].cdat[0] = 0;
 275   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 276   1              OneTime[0].cdat[2] = 0;
 277   1              OneTime[0].cdat[3] = 0;
 278   1              OneTime[0].cdat[4] = 0;
 279   1              OneTime[0].cdat[5] = 0;
 280   1              OneTime[0].cdat[6] = 0;
 281   1              OneTime[0].cdat[7] = 0;
 282   1              OneTime[0].sz = 8;
 283   1              OneTime[0].arbID = 0x4F6 | 0;
 284   1      //      AddMessage(0,0x4F6,20000,8,OneTime[0].cdat); */
 285   1      
 286   1              /// STATUS_LIN
 287   1              OneTime[0].cdat[0] = 0x08;
 288   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 289   1              OneTime[0].cdat[2] = 0;
 290   1              OneTime[0].cdat[3] = 0;
 291   1              OneTime[0].cdat[4] = 0;
 292   1              OneTime[0].cdat[5] = 0;
 293   1              OneTime[0].cdat[6] = 0;
 294   1              OneTime[0].cdat[7] = 0;
 295   1              AddMessage(0,0x5B6,1000,8,OneTime[0].cdat); 
 296   1      
 297   1      
 298   1              /// IPC_VEHICLE_SETUP
 299   1      /*      OneTime[0].cdat[0] = 0x02;
 300   1              OneTime[0].cdat[1] = 0x65;      // using OneTime structure as temp storage
 301   1              OneTime[0].cdat[2] = 0x68;
 302   1              OneTime[0].cdat[3] = 0x40;
 303   1              OneTime[0].cdat[4] = 0x05;
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 6   

 304   1              OneTime[0].cdat[5] = 0x19;
 305   1              OneTime[0].cdat[6] = 0x90;
 306   1              OneTime[0].cdat[7] = 0x80;
 307   1              AddMessage(0,0x5BC,1000,8,OneTime[0].cdat); */
 308   1              OneTime[0].cdat[0] = 0x0B;
 309   1              OneTime[0].cdat[1] = 0x65;      // using OneTime structure as temp storage
 310   1              OneTime[0].cdat[2] = 0x68;
 311   1              OneTime[0].cdat[3] = 0x40;
 312   1              OneTime[0].cdat[4] = 0x05;
 313   1              OneTime[0].cdat[5] = 0x19;
 314   1              OneTime[0].cdat[6] = 0x90;
 315   1              OneTime[0].cdat[7] = 0x80;
 316   1              AddMessage(0,0x5BC,1000,8,OneTime[0].cdat);
 317   1      
 318   1      /*      /// STATUS_TELEMATIC
 319   1              OneTime[0].cdat[0] = 0x10;
 320   1              OneTime[0].cdat[1] = 0x24;      // using OneTime structure as temp storage
 321   1              OneTime[0].cdat[2] = 0;
 322   1              OneTime[0].cdat[3] = 0;
 323   1              OneTime[0].cdat[4] = 0;
 324   1              OneTime[0].cdat[5] = 0;
 325   1              OneTime[0].cdat[6] = 0;
 326   1              OneTime[0].cdat[7] = 0;
 327   1              AddMessage(0,0x5BE,1000,8,OneTime[0].cdat); */
 328   1      
 329   1      /*      /// TRIP_A
 330   1              OneTime[0].cdat[0] = 0;
 331   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 332   1              OneTime[0].cdat[2] = 0;
 333   1              OneTime[0].cdat[3] = 0;
 334   1              OneTime[0].cdat[4] = 0;
 335   1              OneTime[0].cdat[5] = 0;
 336   1              OneTime[0].cdat[6] = 0;
 337   1              OneTime[0].cdat[7] = 0;
 338   1              AddMessage(0,0x5C0,1000,8,OneTime[0].cdat); */
 339   1      
 340   1              /// BCM_VPS2
 341   1              OneTime[0].cdat[0] = 0;
 342   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 343   1              OneTime[0].cdat[2] = 0;
 344   1              AddMessage(0,0x5C2,1000,3,OneTime[0].cdat); 
 345   1      
 346   1      /*      /// TRIP_B
 347   1              OneTime[0].cdat[0] = 0;
 348   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 349   1              OneTime[0].cdat[2] = 0;
 350   1              OneTime[0].cdat[3] = 0;
 351   1              OneTime[0].cdat[4] = 0;
 352   1              OneTime[0].cdat[5] = 0;
 353   1              OneTime[0].cdat[6] = 0;
 354   1              OneTime[0].cdat[7] = 0;
 355   1              AddMessage(0,0x5C4,1000,8,OneTime[0].cdat); */
 356   1      
 357   1              /// IPC_VEHICLE_SETUP2
 358   1              OneTime[0].cdat[0] = 0x65;
 359   1              OneTime[0].cdat[1] = 0x43;      // using OneTime structure as temp storage
 360   1              OneTime[0].cdat[2] = 0x40;
 361   1              OneTime[0].cdat[3] = 0;
 362   1              OneTime[0].cdat[4] = 0x02;
 363   1              OneTime[0].cdat[5] = 0x01;
 364   1              OneTime[0].cdat[6] = 0;
 365   1              OneTime[0].cdat[7] = 0;
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 7   

 366   1              AddMessage(0,0x5CE,1000,8,OneTime[0].cdat); 
 367   1      
 368   1      /*      /// CTRL_AMP
 369   1              OneTime[0].cdat[0] = 0;
 370   1              OneTime[0].cdat[1] = 0x14;      // using OneTime structure as temp storage
 371   1              OneTime[0].cdat[2] = 0x50;
 372   1              OneTime[0].cdat[3] = 0x50;
 373   1              OneTime[0].cdat[4] = 0x52;
 374   1              OneTime[0].cdat[5] = 0x80;
 375   1              OneTime[0].cdat[6] = 0;
 376   1              OneTime[0].cdat[7] = 0;
 377   1              AddMessage(0,0x5C6,1000,8,OneTime[0].cdat); */
 378   1      
 379   1      /*      /// TELEMATIC_CLIMATE_SETUP
 380   1              OneTime[0].cdat[0] = 0;
 381   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 382   1              OneTime[0].cdat[2] = 0;
 383   1              OneTime[0].cdat[3] = 0;
 384   1              AddMessage(0,0x5C8,1000,4,OneTime[0].cdat); */
 385   1      
 386   1              /// BCM_IGNITION_ON_COUNTER
 387   1              OneTime[0].cdat[0] = 0;
 388   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 389   1              AddMessage(0,0x75C,1000,2,OneTime[0].cdat); 
 390   1      
 391   1              /// TRIP_A_B
 392   1      /*      OneTime[0].cdat[0] = 0;
 393   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 394   1              OneTime[0].cdat[2] = 0;
 395   1              OneTime[0].cdat[3] = 0;
 396   1              OneTime[0].cdat[4] = 0;
 397   1              OneTime[0].cdat[5] = 0;
 398   1              AddMessage(0,0x760,1000,6,OneTime[0].cdat); */
 399   1              OneTime[0].cdat[0] = 0;
 400   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 401   1              OneTime[0].cdat[2] = 0x03;
 402   1              OneTime[0].cdat[3] = 0xE8;
 403   1              OneTime[0].cdat[4] = 0;
 404   1              OneTime[0].cdat[5] = 0;
 405   1              AddMessage(0,0x760,1000,6,OneTime[0].cdat); 
 406   1      
 407   1      /*      /// SERVICEINFO2
 408   1              OneTime[0].cdat[0] = 0;
 409   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 410   1              OneTime[0].cdat[2] = 0;
 411   1              OneTime[0].cdat[3] = 0;
 412   1              OneTime[0].cdat[4] = 0;
 413   1              OneTime[0].cdat[5] = 0;
 414   1              OneTime[0].cdat[6] = 0;
 415   1              OneTime[0].cdat[7] = 0;
 416   1              AddMessage(0,0x762,1000,8,OneTime[0].cdat);     */
 417   1      
 418   1              /// TIME_DATE
 419   1              OneTime[0].cdat[0] = 0;
 420   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 421   1              OneTime[0].cdat[2] = 0;
 422   1              OneTime[0].cdat[3] = 0;
 423   1              OneTime[0].cdat[4] = 0;
 424   1              OneTime[0].cdat[5] = 0;
 425   1              AddMessage(0,0x764,1000,6,OneTime[0].cdat);
 426   1      
 427   1      
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 8   

 428   1      /*      /// CLUSTER_INDICATION
 429   1              OneTime[0].cdat[0] = 0;
 430   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 431   1              OneTime[0].cdat[2] = 0;
 432   1              OneTime[0].cdat[3] = 0;
 433   1              OneTime[0].cdat[4] = 0;
 434   1              OneTime[0].cdat[5] = 0;
 435   1              OneTime[0].cdat[6] = 0;
 436   1              OneTime[0].cdat[7] = 0;
 437   1              OneTime[0].sz = 8;
 438   1              OneTime[0].arbID = 0x7B6 | 0; */
 439   1              
 440   1              /// U_CONN_SEED
 441   1              OneTime[0].cdat[0] = 0;
 442   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 443   1              OneTime[0].cdat[2] = 0;
 444   1              OneTime[0].cdat[3] = 0;
 445   1              OneTime[0].sz = 4;
 446   1              OneTime[0].arbID = 0x7B8 | 0; 
 447   1      
 448   1      //      AddMessage(0,0x7B8,1000,4,OneTime[0].cdat); 
 449   1      
 450   1              /// STATUS_CCAN6
 451   1              OneTime[0].cdat[0] = 0;
 452   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 453   1              OneTime[0].cdat[2] = 0;
 454   1              AddMessage(0,0x7C0,2000,3,OneTime[0].cdat);
 455   1      
 456   1      /*      /// CFG_DATA_CODE_REQUEST
 457   1              OneTime[0].cdat[0] = 0;
 458   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 459   1              OneTime[0].cdat[2] = 0;
 460   1              OneTime[0].cdat[3] = 0;
 461   1              OneTime[0].cdat[4] = 0;
 462   1              OneTime[0].cdat[5] = 0;
 463   1              AddMessage(0,0x1E114000,20000,6,OneTime[0].cdat); */
 464   1      
 465   1      /*      /// CFG_DATA_CODE_REQUEST
 466   1              OneTime[0].cdat[0] = 0;
 467   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 468   1              OneTime[0].cdat[2] = 0;
 469   1              OneTime[0].cdat[3] = 0;
 470   1              OneTime[0].cdat[4] = 0;
 471   1              OneTime[0].cdat[5] = 0;
 472   1              OneTime[0].sz = 6;
 473   1              OneTime[0].arbID = 0x1E114000 | 0; */
 474   1      
 475   1              /// build repetative message 1E340000 on CAN0 (IGN)
 476   1              OneTime[0].cdat[0] = 0;
 477   1              OneTime[0].cdat[1] = 0x02;      // using OneTime structure as temp storage
 478   1              OneTime[0].cdat[2] = 0xFF;
 479   1              OneTime[0].cdat[3] = 0xFF;
 480   1              OneTime[0].cdat[4] = 0xFF;
 481   1              OneTime[0].cdat[5] = 0xFF;
 482   1              AddMessage(0,0x1E340000,1000,6,OneTime[0].cdat); 
 483   1      
 484   1      /*      /// build repetative message 1E340000 on CAN0 (IGN) - ETM
 485   1              OneTime[0].cdat[0] = 0;
 486   1              OneTime[0].cdat[1] = 0xCE;      // using OneTime structure as temp storage
 487   1              AddMessage(0,0x1E340024,1000,2,OneTime[0].cdat); */
 488   1      
 489   1      /*************************************************************************
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 9   

 490   1              Button setup
 491   1              example below -
 492   1              pressing button 1 causes byte 5 of message 0x6E2 to be altered to 0xAA 
 493   1              for the next 5 outputs. The mask clears byte 5 leaving the rest alone.  
 494   1              The value (0xAA) is ORed into byte 5.
 495   1      **************************************************************************/
 496   1              #define BUTTONMASK 0xF  // only button 1 defined (bit 1)        
 497   1              
 498   1              //Vol_Up
 499   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 500   1              OneTime[0].cdat[1] = 0xFF;
 501   1              OneTime[0].cdat[2] = 0xFF;              // using OneTime structure as temp storage
 502   1              OneTime[0].cdat[3] = 0;
 503   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 504   1              OneTime[1].cdat[1] = 0;
 505   1              OneTime[1].cdat[2] = 0;
 506   1              OneTime[1].cdat[3] = 0x01;
 507   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 508   1              SimpleButtonConfig(19,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 509   1               
 510   1              
 511   1              //Vol_Dwn
 512   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 513   1              OneTime[0].cdat[1] = 0xFF;
 514   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 515   1              OneTime[0].cdat[3] = 0;
 516   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 517   1              OneTime[1].cdat[1] = 0;
 518   1              OneTime[1].cdat[2] = 0;
 519   1              OneTime[1].cdat[3] = 0x04;
 520   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 521   1              SimpleButtonConfig(9,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 522   1      
 523   1              //Mode
 524   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 525   1              OneTime[0].cdat[1] = 0;
 526   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 527   1              OneTime[0].cdat[3] = 0xFF;
 528   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 529   1              OneTime[1].cdat[1] = 0x01;
 530   1              OneTime[1].cdat[2] = 0;
 531   1              OneTime[1].cdat[3] = 0;
 532   1              SimpleButtonConfig(18,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 533   1      
 534   1      
 535   1              //Presets
 536   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 537   1              OneTime[0].cdat[1] = 0xFF;
 538   1              OneTime[0].cdat[2] = 0; // using OneTime structure as temp storage
 539   1              OneTime[0].cdat[3] = 0xFF;
 540   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 541   1              OneTime[1].cdat[1] = 0;
 542   1              OneTime[1].cdat[2] = 0x04;
 543   1              OneTime[1].cdat[3] = 0;
 544   1              SimpleButtonConfig(8,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 545   1      
 546   1      /*      // Presets
 547   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 548   1              OneTime[0].cdat[1] = 0xFF;
 549   1              OneTime[0].cdat[2] = 0xFF;              // using OneTime structure as temp storage
 550   1              OneTime[0].cdat[3] = 0xFF;
 551   1              OneTime[0].cdat[4] = 0xFF;              // values (ORed)
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 10  

 552   1              OneTime[0].cdat[5] = 0;
 553   1              OneTime[0].cdat[6] = 0xFF;
 554   1              OneTime[0].cdat[7] = 0xFF;
 555   1              OneTime[1].cdat[0] = 0; 
 556   1              OneTime[1].cdat[1] = 0;
 557   1              OneTime[1].cdat[2] = 0; 
 558   1              OneTime[1].cdat[3] = 0;
 559   1              OneTime[1].cdat[4] = 0;
 560   1              OneTime[1].cdat[5] = 0x08;
 561   1              OneTime[1].cdat[6] = 0;
 562   1              OneTime[1].cdat[7] = 0;
 563   1              SimpleButtonConfig(8,0,0x41A,OneTime[0].cdat,OneTime[1].cdat,1); */
 564   1      
 565   1              // Seek Up
 566   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 567   1              OneTime[0].cdat[1] = 0xFF;
 568   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 569   1              OneTime[0].cdat[3] = 0;
 570   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 571   1              OneTime[1].cdat[1] = 0;
 572   1              OneTime[1].cdat[2] = 0;
 573   1              OneTime[1].cdat[3] = 0x40;
 574   1              SimpleButtonConfig(17,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 575   1      
 576   1              //Seek Down
 577   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 578   1              OneTime[0].cdat[1] = 0xFF;
 579   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
 580   1              OneTime[0].cdat[3] = 0xFF;
 581   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 582   1              OneTime[1].cdat[1] = 0;
 583   1              OneTime[1].cdat[2] = 0x01;
 584   1              OneTime[1].cdat[3] = 0;
 585   1              SimpleButtonConfig(7,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 586   1      
 587   1              // Phone Pickup
 588   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 589   1              OneTime[0].cdat[1] = 0xFF;
 590   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
 591   1              OneTime[0].cdat[3] = 0xFF;
 592   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 593   1              OneTime[1].cdat[1] = 0;
 594   1              OneTime[1].cdat[2] = 0x10;
 595   1              OneTime[1].cdat[3] = 0;
 596   1              SimpleButtonConfig(16,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 597   1      
 598   1              // Phone Hangup
 599   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 600   1              OneTime[0].cdat[1] = 0xFF;
 601   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
 602   1              OneTime[0].cdat[3] = 0xFF;
 603   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 604   1              OneTime[1].cdat[1] = 0;
 605   1              OneTime[1].cdat[2] = 0x40;
 606   1              OneTime[1].cdat[3] = 0;
 607   1              SimpleButtonConfig(6,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 608   1      
 609   1              // VR
 610   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 611   1              OneTime[0].cdat[1] = 0;
 612   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 613   1              OneTime[0].cdat[3] = 0xFF;
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 11  

 614   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 615   1              OneTime[1].cdat[1] = 0x04;
 616   1              OneTime[1].cdat[2] = 0;
 617   1              OneTime[1].cdat[3] = 0;
 618   1              SimpleButtonConfig(15,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 619   1      
 620   1              // Radio Off
 621   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 622   1              OneTime[0].cdat[1] = 0xFF;
 623   1              OneTime[0].cdat[2] = 0xFF;              // using OneTime structure as temp storage
 624   1              OneTime[0].cdat[3] = 0xFF;
 625   1              OneTime[0].cdat[4] = 0xFF;              // values (ORed)
 626   1              OneTime[0].cdat[5] = 0;
 627   1              OneTime[0].cdat[6] = 0xFF;
 628   1              OneTime[0].cdat[7] = 0xFF;
 629   1              OneTime[1].cdat[0] = 0; 
 630   1              OneTime[1].cdat[1] = 0;
 631   1              OneTime[1].cdat[2] = 0; 
 632   1              OneTime[1].cdat[3] = 0;
 633   1              OneTime[1].cdat[4] = 0;
 634   1              OneTime[1].cdat[5] = 0x10;
 635   1              OneTime[1].cdat[6] = 0;
 636   1              OneTime[1].cdat[7] = 0;
 637   1              SimpleButtonConfig(5,0,0x41A,OneTime[0].cdat,OneTime[1].cdat,1); 
 638   1      
 639   1              //Mute
 640   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 641   1              OneTime[0].cdat[1] = 0xFF;
 642   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 643   1              OneTime[0].cdat[3] = 0;
 644   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 645   1              OneTime[1].cdat[1] = 0;
 646   1              OneTime[1].cdat[2] = 0;
 647   1              OneTime[1].cdat[3] = 0x10;
 648   1              SimpleButtonConfig(14,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 649   1      
 650   1              // ICS Buttons ------------------------------------------------------------------------------------
 651   1      
 652   1              // Back
 653   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 654   1              OneTime[0].cdat[1] = 0xFF;
 655   1              OneTime[0].cdat[2] = 0xFF;              // using OneTime structure as temp storage
 656   1              OneTime[0].cdat[3] = 0xFF;
 657   1              OneTime[0].cdat[4] = 0xFF;              // values (ORed)
 658   1              OneTime[0].cdat[5] = 0;
 659   1              OneTime[0].cdat[6] = 0xFF;
 660   1              OneTime[0].cdat[7] = 0xFF;
 661   1              OneTime[1].cdat[0] = 0; 
 662   1              OneTime[1].cdat[1] = 0;
 663   1              OneTime[1].cdat[2] = 0; 
 664   1              OneTime[1].cdat[3] = 0;
 665   1              OneTime[1].cdat[4] = 0;
 666   1              OneTime[1].cdat[5] = 0x02;
 667   1              OneTime[1].cdat[6] = 0;
 668   1              OneTime[1].cdat[7] = 0;
 669   1              SimpleButtonConfig(4,0,0x41A,OneTime[0].cdat,OneTime[1].cdat,1); 
 670   1      
 671   1              // Browse/Enter
 672   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 673   1              OneTime[0].cdat[1] = 0xFF;
 674   1              OneTime[0].cdat[2] = 0xFF;              // using OneTime structure as temp storage
 675   1              OneTime[0].cdat[3] = 0xFF;
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 12  

 676   1              OneTime[0].cdat[4] = 0xFF;              // values (ORed)
 677   1              OneTime[0].cdat[5] = 0;
 678   1              OneTime[0].cdat[6] = 0xFF;
 679   1              OneTime[0].cdat[7] = 0xFF;
 680   1              OneTime[1].cdat[0] = 0; 
 681   1              OneTime[1].cdat[1] = 0;
 682   1              OneTime[1].cdat[2] = 0; 
 683   1              OneTime[1].cdat[3] = 0;
 684   1              OneTime[1].cdat[4] = 0;
 685   1              OneTime[1].cdat[5] = 0x08;
 686   1              OneTime[1].cdat[6] = 0;
 687   1              OneTime[1].cdat[7] = 0;
 688   1              SimpleButtonConfig(13,0,0x41A,OneTime[0].cdat,OneTime[1].cdat,1);
 689   1      
 690   1              // Engineering Mode
 691   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 692   1              OneTime[0].cdat[1] = 0xFF;
 693   1              OneTime[0].cdat[2] = 0xFF;              // using OneTime structure as temp storage
 694   1              OneTime[0].cdat[3] = 0xFF;
 695   1              OneTime[0].cdat[4] = 0;                 // values (ORed)
 696   1              OneTime[0].cdat[5] = 0xFF;
 697   1              OneTime[0].cdat[6] = 0xFF;
 698   1              OneTime[0].cdat[7] = 0xFF;
 699   1              OneTime[1].cdat[0] = 0; 
 700   1              OneTime[1].cdat[1] = 0;
 701   1              OneTime[1].cdat[2] = 0; 
 702   1              OneTime[1].cdat[3] = 0;
 703   1              OneTime[1].cdat[4] = 0x30;
 704   1              OneTime[1].cdat[5] = 0;
 705   1              OneTime[1].cdat[6] = 0;
 706   1              OneTime[1].cdat[7] = 0;
 707   1              SimpleButtonConfig(12,0,0x41A,OneTime[0].cdat,OneTime[1].cdat,7);
 708   1      
 709   1      
 710   1              /*
 711   1              // Screen Off
 712   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 713   1              OneTime[0].cdat[1] = 0xFF;
 714   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
 715   1              OneTime[0].cdat[3] = 0xFF;
 716   1              OneTime[0].cdat[4] = 0xFF;              // values (ORed)
 717   1              OneTime[0].cdat[5] = 0xFF;
 718   1              OneTime[0].cdat[6] = 0xFF;
 719   1              OneTime[0].cdat[7] = 0xFF;
 720   1              OneTime[1].cdat[0] = 0; 
 721   1              OneTime[1].cdat[1] = 0;
 722   1              OneTime[1].cdat[2] = 0x0C;      
 723   1              OneTime[1].cdat[3] = 0;
 724   1              OneTime[1].cdat[4] = 0;
 725   1              OneTime[1].cdat[5] = 0;
 726   1              OneTime[1].cdat[6] = 0;
 727   1              OneTime[1].cdat[7] = 0;
 728   1              SimpleButtonConfig(5,0,0x41A,OneTime[0].cdat,OneTime[1].cdat,1);
 729   1              
 730   1      
 731   1              // Mute
 732   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 733   1              OneTime[0].cdat[1] = 0xFF;
 734   1              OneTime[0].cdat[2] = 0xFF;              // using OneTime structure as temp storage
 735   1              OneTime[0].cdat[3] = 0;
 736   1              OneTime[0].cdat[4] = 0xFF;              // values (ORed)
 737   1              OneTime[0].cdat[5] = 0xFF;
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 13  

 738   1              OneTime[0].cdat[6] = 0xFF;
 739   1              OneTime[0].cdat[7] = 0xFF;
 740   1              OneTime[1].cdat[0] = 0; 
 741   1              OneTime[1].cdat[1] = 0;
 742   1              OneTime[1].cdat[2] = 0; 
 743   1              OneTime[1].cdat[3] = 0xC0;
 744   1              OneTime[1].cdat[4] = 0;
 745   1              OneTime[1].cdat[5] = 0;
 746   1              OneTime[1].cdat[6] = 0;
 747   1              OneTime[1].cdat[7] = 0;
 748   1      
 749   1              // Back
 750   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 751   1              OneTime[0].cdat[1] = 0xFF;
 752   1              OneTime[0].cdat[2] = 0xFF;              // using OneTime structure as temp storage
 753   1              OneTime[0].cdat[3] = 0;
 754   1              OneTime[0].cdat[4] = 0xFF;              // values (ORed)
 755   1              OneTime[0].cdat[5] = 0xFF;
 756   1              OneTime[0].cdat[6] = 0xFF;
 757   1              OneTime[0].cdat[7] = 0xFF;
 758   1              OneTime[1].cdat[0] = 0; 
 759   1              OneTime[1].cdat[1] = 0;
 760   1              OneTime[1].cdat[2] = 0; 
 761   1              OneTime[1].cdat[3] = 0xC0;
 762   1              OneTime[1].cdat[4] = 0;
 763   1              OneTime[1].cdat[5] = 0;
 764   1              OneTime[1].cdat[6] = 0;
 765   1              OneTime[1].cdat[7] = 0;
 766   1              SimpleButtonConfig(4,0,0x41A,OneTime[0].cdat,OneTime[1].cdat,1);
 767   1              */
 768   1       
 769   1              /*
 770   1              // Screenshot
 771   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 772   1              OneTime[0].cdat[1] = 0xFF;
 773   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 774   1              OneTime[0].cdat[3] = 0;
 775   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 776   1              OneTime[1].cdat[1] = 0;
 777   1              OneTime[1].cdat[2] = 0;
 778   1              OneTime[1].cdat[3] = 0x04;
 779   1              SimpleButtonConfig(3,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 780   1      
 781   1              // ENG. Mode
 782   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 783   1              OneTime[0].cdat[1] = 0xFF;
 784   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 785   1              OneTime[0].cdat[3] = 0;
 786   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 787   1              OneTime[1].cdat[1] = 0;
 788   1              OneTime[1].cdat[2] = 0;
 789   1              OneTime[1].cdat[3] = 0x04;
 790   1              SimpleButtonConfig(12,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 791   1      
 792   1              // Dealer Mode
 793   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 794   1              OneTime[0].cdat[1] = 0xFF;
 795   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 796   1              OneTime[0].cdat[3] = 0;
 797   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 798   1              OneTime[1].cdat[1] = 0;
 799   1              OneTime[1].cdat[2] = 0;
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 14  

 800   1              OneTime[1].cdat[3] = 0x04;
 801   1              SimpleButtonConfig(2,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 802   1      
 803   1              // 911
 804   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 805   1              OneTime[0].cdat[1] = 0xFF;
 806   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 807   1              OneTime[0].cdat[3] = 0;
 808   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 809   1              OneTime[1].cdat[1] = 0;
 810   1              OneTime[1].cdat[2] = 0;
 811   1              OneTime[1].cdat[3] = 0x04;
 812   1              SimpleButtonConfig(11,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 813   1      
 814   1              // Assist
 815   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 816   1              OneTime[0].cdat[1] = 0xFF;
 817   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 818   1              OneTime[0].cdat[3] = 0;
 819   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 820   1              OneTime[1].cdat[1] = 0;
 821   1              OneTime[1].cdat[2] = 0;
 822   1              OneTime[1].cdat[3] = 0x04;
 823   1              SimpleButtonConfig(1,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 824   1      
 825   1              // Door Ajar
 826   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 827   1              OneTime[0].cdat[1] = 0xFF;
 828   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 829   1              OneTime[0].cdat[3] = 0;
 830   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 831   1              OneTime[1].cdat[1] = 0;
 832   1              OneTime[1].cdat[2] = 0;
 833   1              OneTime[1].cdat[3] = 0x04;
 834   1              SimpleButtonConfig(10,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 835   1      
 836   1              // Theft Alarm
 837   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 838   1              OneTime[0].cdat[1] = 0xFF;
 839   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 840   1              OneTime[0].cdat[3] = 0;
 841   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 842   1              OneTime[1].cdat[1] = 0;
 843   1              OneTime[1].cdat[2] = 0;
 844   1              OneTime[1].cdat[3] = 0x04;
 845   1              SimpleButtonConfig(0,0,0x2EE,OneTime[0].cdat,OneTime[1].cdat,1);
 846   1              */
 847   1      
 848   1      
 849   1      /*************************************************************************
 850   1              RxMessage filters / traps
 851   1              Below example:
 852   1              First half, Watches for ID 0x6E8 on can port 1 (C).  Only byte 3 matters 
 853   1              as the mask is set to 0's for all else.  The matching value required in  
 854   1              byte 3 is 0x58. 8 bytes expected.
 855   1              Second half, configures output message 0x6E3 on port 1 (C). 8 bytes in 
 856   1              count.  mask is ANDed with cyclic message and ORed with value, but in 
 857   1              this example there is no cyclic message, therefor mask is ignored and 
 858   1              value is just output as the data 1 time. Take care to use the index value
 859   1              returned from the first function as input parameter to 2nd function
 860   1      **************************************************************************/
 861   1      
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 15  

 862   1              OneTime[0].cdat[0] = 0;         // mask bits (0's don't cares, 1's are matches)
 863   1              OneTime[0].cdat[1] = 0;
 864   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
 865   1              OneTime[0].cdat[3] = 0xFF;      // this byte matters
 866   1              OneTime[0].cdat[4] = 0;
 867   1              OneTime[0].cdat[5] = 0;  
 868   1              OneTime[0].cdat[6] = 0;
 869   1              OneTime[0].cdat[7] = 0;
 870   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 871   1              OneTime[1].cdat[1] = 0;
 872   1              OneTime[1].cdat[2] = 0;
 873   1              OneTime[1].cdat[3] = 0x58;      // selector switches to x58 causes triggers
 874   1              OneTime[1].cdat[4] = 0;
 875   1              OneTime[1].cdat[5] = 0;
 876   1              OneTime[1].cdat[6] = 0;
 877   1              OneTime[1].cdat[7] = 0;
 878   1      // configure Rx filter, look for this message match
 879   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
 880   1              index = RxMessageConfig1(1,0x6E8,OneTime[0].cdat,OneTime[1].cdat,8);
 881   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 882   1              OneTime[0].cdat[1] = 0xFF;
 883   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 884   1              OneTime[0].cdat[3] = 0xFF;
 885   1              OneTime[0].cdat[4] = 0xFF;
 886   1              OneTime[0].cdat[5] = 0xFF;
 887   1              OneTime[0].cdat[6] = 0xFF;
 888   1              OneTime[0].cdat[7] = 0xFF;
 889   1              OneTime[1].cdat[0] = 0x88;      // values (ORed)
 890   1              OneTime[1].cdat[1] = 0x99;
 891   1              OneTime[1].cdat[2] = 0xAA;
 892   1              OneTime[1].cdat[3] = 0xBB;
 893   1              OneTime[1].cdat[4] = 0xCC;
 894   1              OneTime[1].cdat[5] = 0xDD;
 895   1              OneTime[1].cdat[6] = 0xEE;
 896   1              OneTime[1].cdat[7] = 0xFF;
 897   1      // configure Tx output caused by above Recieved message
 898   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
 899   1              RxMessageConfig2(index,1,0x6E3,OneTime[0].cdat,OneTime[1].cdat,8,1);
 900   1              
 901   1              //  Check for any language change requests
 902   1      
 903   1              //  Check for request to switch to CHS
 904   1              OneTime[0].cdat[0] = 0xFF;              // mask bits (0's don't cares, 1's are matches)
 905   1              OneTime[0].cdat[1] = 0;
 906   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
 907   1              OneTime[0].cdat[3] = 0; // this byte matters
 908   1              OneTime[0].cdat[4] = 0;
 909   1              OneTime[0].cdat[5] = 0;  
 910   1              OneTime[0].cdat[6] = 0;
 911   1              OneTime[0].cdat[7] = 0;
 912   1              OneTime[1].cdat[0] = 0x0E;              // values (ORed)
 913   1              OneTime[1].cdat[1] = 0;
 914   1              OneTime[1].cdat[2] = 0;
 915   1              OneTime[1].cdat[3] = 0; // selector switches to x58 causes triggers
 916   1              OneTime[1].cdat[4] = 0;
 917   1              OneTime[1].cdat[5] = 0;
 918   1              OneTime[1].cdat[6] = 0;
 919   1              OneTime[1].cdat[7] = 0;
 920   1      // configure Rx filter, look for this message match
 921   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
 922   1              index = RxMessageConfig1(0,0x09E,OneTime[0].cdat,OneTime[1].cdat,8);
 923   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 16  

 924   1              OneTime[0].cdat[1] = 0xFF;
 925   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 926   1              OneTime[0].cdat[3] = 0xFF;
 927   1              OneTime[0].cdat[4] = 0xFF;      
 928   1              OneTime[0].cdat[5] = 0xFF;
 929   1              OneTime[0].cdat[6] = 0xFF;
 930   1              OneTime[0].cdat[7] = 0xFF;
 931   1              OneTime[1].cdat[0] = 0x0E;              // values (ORed)
 932   1              OneTime[1].cdat[1] = 0;
 933   1              OneTime[1].cdat[2] = 0;
 934   1              OneTime[1].cdat[3] = 0;
 935   1              OneTime[1].cdat[4] = 0;
 936   1              OneTime[1].cdat[5] = 0;
 937   1              OneTime[1].cdat[6] = 0;
 938   1              OneTime[1].cdat[7] = 0;
 939   1      // configure Tx output caused by above Recieved message
 940   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
 941   1              RxMessageConfig2(index,0,0x5BC,OneTime[0].cdat,OneTime[1].cdat,8,0);
 942   1      
 943   1      
 944   1              //  Check for request to switch to JAP
 945   1              OneTime[0].cdat[0] = 0xFF;              // mask bits (0's don't cares, 1's are matches)
 946   1              OneTime[0].cdat[1] = 0;
 947   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
 948   1              OneTime[0].cdat[3] = 0; // this byte matters
 949   1              OneTime[0].cdat[4] = 0;
 950   1              OneTime[0].cdat[5] = 0;  
 951   1              OneTime[0].cdat[6] = 0;
 952   1              OneTime[0].cdat[7] = 0;
 953   1              OneTime[1].cdat[0] = 0x0F;              // values (ORed)
 954   1              OneTime[1].cdat[1] = 0;
 955   1              OneTime[1].cdat[2] = 0;
 956   1              OneTime[1].cdat[3] = 0; // selector switches to x58 causes triggers
 957   1              OneTime[1].cdat[4] = 0;
 958   1              OneTime[1].cdat[5] = 0;
 959   1              OneTime[1].cdat[6] = 0;
 960   1              OneTime[1].cdat[7] = 0;
 961   1      // configure Rx filter, look for this message match
 962   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
 963   1              index = RxMessageConfig1(0,0x09E,OneTime[0].cdat,OneTime[1].cdat,8);
 964   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
 965   1              OneTime[0].cdat[1] = 0xFF;
 966   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 967   1              OneTime[0].cdat[3] = 0xFF;
 968   1              OneTime[0].cdat[4] = 0xFF;      
 969   1              OneTime[0].cdat[5] = 0xFF;
 970   1              OneTime[0].cdat[6] = 0xFF;
 971   1              OneTime[0].cdat[7] = 0xFF;
 972   1              OneTime[1].cdat[0] = 0x0F;              // values (ORed)
 973   1              OneTime[1].cdat[1] = 0;
 974   1              OneTime[1].cdat[2] = 0;
 975   1              OneTime[1].cdat[3] = 0;
 976   1              OneTime[1].cdat[4] = 0;
 977   1              OneTime[1].cdat[5] = 0;
 978   1              OneTime[1].cdat[6] = 0;
 979   1              OneTime[1].cdat[7] = 0;
 980   1      // configure Tx output caused by above Recieved message
 981   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
 982   1              RxMessageConfig2(index,0,0x5BC,OneTime[0].cdat,OneTime[1].cdat,8,0);
 983   1      
 984   1      
 985   1      //  Check for request to switch to KOR
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 17  

 986   1              OneTime[0].cdat[0] = 0xFF;              // mask bits (0's don't cares, 1's are matches)
 987   1              OneTime[0].cdat[1] = 0;
 988   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
 989   1              OneTime[0].cdat[3] = 0; // this byte matters
 990   1              OneTime[0].cdat[4] = 0;
 991   1              OneTime[0].cdat[5] = 0;  
 992   1              OneTime[0].cdat[6] = 0;
 993   1              OneTime[0].cdat[7] = 0;
 994   1              OneTime[1].cdat[0] = 0x10;              // values (ORed)
 995   1              OneTime[1].cdat[1] = 0;
 996   1              OneTime[1].cdat[2] = 0;
 997   1              OneTime[1].cdat[3] = 0; // selector switches to x58 causes triggers
 998   1              OneTime[1].cdat[4] = 0;
 999   1              OneTime[1].cdat[5] = 0;
1000   1              OneTime[1].cdat[6] = 0;
1001   1              OneTime[1].cdat[7] = 0;
1002   1      // configure Rx filter, look for this message match
1003   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
1004   1              index = RxMessageConfig1(0,0x09E,OneTime[0].cdat,OneTime[1].cdat,8);
1005   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
1006   1              OneTime[0].cdat[1] = 0xFF;
1007   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1008   1              OneTime[0].cdat[3] = 0xFF;
1009   1              OneTime[0].cdat[4] = 0xFF;      
1010   1              OneTime[0].cdat[5] = 0xFF;
1011   1              OneTime[0].cdat[6] = 0xFF;
1012   1              OneTime[0].cdat[7] = 0xFF;
1013   1              OneTime[1].cdat[0] = 0x10;              // values (ORed)
1014   1              OneTime[1].cdat[1] = 0;
1015   1              OneTime[1].cdat[2] = 0;
1016   1              OneTime[1].cdat[3] = 0;
1017   1              OneTime[1].cdat[4] = 0;
1018   1              OneTime[1].cdat[5] = 0;
1019   1              OneTime[1].cdat[6] = 0;
1020   1              OneTime[1].cdat[7] = 0;
1021   1      // configure Tx output caused by above Recieved message
1022   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
1023   1              RxMessageConfig2(index,0,0x5BC,OneTime[0].cdat,OneTime[1].cdat,8,0);
1024   1      
1025   1      
1026   1              //  Check for request to switch from ENG (US)
1027   1              OneTime[0].cdat[0] = 0xFF;              // mask bits (0's don't cares, 1's are matches)
1028   1              OneTime[0].cdat[1] = 0;
1029   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
1030   1              OneTime[0].cdat[3] = 0; // this byte matters
1031   1              OneTime[0].cdat[4] = 0;
1032   1              OneTime[0].cdat[5] = 0;  
1033   1              OneTime[0].cdat[6] = 0;
1034   1              OneTime[0].cdat[7] = 0;
1035   1              OneTime[1].cdat[0] = 0x0B;              // values (ORed)
1036   1              OneTime[1].cdat[1] = 0;
1037   1              OneTime[1].cdat[2] = 0;
1038   1              OneTime[1].cdat[3] = 0; // selector switches to x58 causes triggers
1039   1              OneTime[1].cdat[4] = 0;
1040   1              OneTime[1].cdat[5] = 0;
1041   1              OneTime[1].cdat[6] = 0;
1042   1              OneTime[1].cdat[7] = 0;
1043   1      // configure Rx filter, look for this message match
1044   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
1045   1              index = RxMessageConfig1(0,0x09E,OneTime[0].cdat,OneTime[1].cdat,8);
1046   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
1047   1              OneTime[0].cdat[1] = 0xFF;
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 18  

1048   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1049   1              OneTime[0].cdat[3] = 0xFF;
1050   1              OneTime[0].cdat[4] = 0xFF;
1051   1              OneTime[0].cdat[5] = 0xFF;
1052   1              OneTime[0].cdat[6] = 0xFF;
1053   1              OneTime[0].cdat[7] = 0xFF;
1054   1              OneTime[1].cdat[0] = 0x0B;      // values (ORed)
1055   1              OneTime[1].cdat[1] = 0;
1056   1              OneTime[1].cdat[2] = 0;
1057   1              OneTime[1].cdat[3] = 0;
1058   1              OneTime[1].cdat[4] = 0;
1059   1              OneTime[1].cdat[5] = 0;
1060   1              OneTime[1].cdat[6] = 0;
1061   1              OneTime[1].cdat[7] = 0;
1062   1      // configure Tx output caused by above Recieved message
1063   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
1064   1              RxMessageConfig2(index,0,0x5BC,OneTime[0].cdat,OneTime[1].cdat,8,0);
1065   1      
1066   1      
1067   1              //  Check for request to switch to Spanish
1068   1              OneTime[0].cdat[0] = 0xFF;              // mask bits (0's don't cares, 1's are matches)
1069   1              OneTime[0].cdat[1] = 0;
1070   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
1071   1              OneTime[0].cdat[3] = 0; // this byte matters
1072   1              OneTime[0].cdat[4] = 0;
1073   1              OneTime[0].cdat[5] = 0;  
1074   1              OneTime[0].cdat[6] = 0;
1075   1              OneTime[0].cdat[7] = 0;
1076   1              OneTime[1].cdat[0] = 0x03;              // values (ORed)
1077   1              OneTime[1].cdat[1] = 0;
1078   1              OneTime[1].cdat[2] = 0;
1079   1              OneTime[1].cdat[3] = 0; // selector switches to x58 causes triggers
1080   1              OneTime[1].cdat[4] = 0;
1081   1              OneTime[1].cdat[5] = 0;
1082   1              OneTime[1].cdat[6] = 0;
1083   1              OneTime[1].cdat[7] = 0;
1084   1      // configure Rx filter, look for this message match
1085   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
1086   1              index = RxMessageConfig1(0,0x09E,OneTime[0].cdat,OneTime[1].cdat,8);
1087   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
1088   1              OneTime[0].cdat[1] = 0xFF;
1089   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1090   1              OneTime[0].cdat[3] = 0xFF;
1091   1              OneTime[0].cdat[4] = 0xFF;
1092   1              OneTime[0].cdat[5] = 0xFF;
1093   1              OneTime[0].cdat[6] = 0xFF;
1094   1              OneTime[0].cdat[7] = 0xFF;
1095   1              OneTime[1].cdat[0] = 0x03;      // values (ORed)
1096   1              OneTime[1].cdat[1] = 0;
1097   1              OneTime[1].cdat[2] = 0;
1098   1              OneTime[1].cdat[3] = 0;
1099   1              OneTime[1].cdat[4] = 0;
1100   1              OneTime[1].cdat[5] = 0;
1101   1              OneTime[1].cdat[6] = 0;
1102   1              OneTime[1].cdat[7] = 0;
1103   1      // configure Tx output caused by above Recieved message
1104   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
1105   1              RxMessageConfig2(index,0,0x5BC,OneTime[0].cdat,OneTime[1].cdat,8,0);
1106   1      
1107   1              //  Check for request to switch to French
1108   1              OneTime[0].cdat[0] = 0xFF;              // mask bits (0's don't cares, 1's are matches)
1109   1              OneTime[0].cdat[1] = 0;
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 19  

1110   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
1111   1              OneTime[0].cdat[3] = 0; // this byte matters
1112   1              OneTime[0].cdat[4] = 0;
1113   1              OneTime[0].cdat[5] = 0;  
1114   1              OneTime[0].cdat[6] = 0;
1115   1              OneTime[0].cdat[7] = 0;
1116   1              OneTime[1].cdat[0] = 0x04;              // values (ORed)
1117   1              OneTime[1].cdat[1] = 0;
1118   1              OneTime[1].cdat[2] = 0;
1119   1              OneTime[1].cdat[3] = 0; // selector switches to x58 causes triggers
1120   1              OneTime[1].cdat[4] = 0;
1121   1              OneTime[1].cdat[5] = 0;
1122   1              OneTime[1].cdat[6] = 0;
1123   1              OneTime[1].cdat[7] = 0;
1124   1      // configure Rx filter, look for this message match
1125   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
1126   1              index = RxMessageConfig1(0,0x09E,OneTime[0].cdat,OneTime[1].cdat,8);
1127   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
1128   1              OneTime[0].cdat[1] = 0xFF;
1129   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1130   1              OneTime[0].cdat[3] = 0xFF;
1131   1              OneTime[0].cdat[4] = 0xFF;
1132   1              OneTime[0].cdat[5] = 0xFF;
1133   1              OneTime[0].cdat[6] = 0xFF;
1134   1              OneTime[0].cdat[7] = 0xFF;
1135   1              OneTime[1].cdat[0] = 0x04;      // values (ORed)
1136   1              OneTime[1].cdat[1] = 0;
1137   1              OneTime[1].cdat[2] = 0;
1138   1              OneTime[1].cdat[3] = 0;
1139   1              OneTime[1].cdat[4] = 0;
1140   1              OneTime[1].cdat[5] = 0;
1141   1              OneTime[1].cdat[6] = 0;
1142   1              OneTime[1].cdat[7] = 0;
1143   1      // configure Tx output caused by above Recieved message
1144   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
1145   1              RxMessageConfig2(index,0,0x5BC,OneTime[0].cdat,OneTime[1].cdat,8,0);
1146   1      
1147   1      
1148   1      
1149   1      
1150   1      //  Check for request to switch to Canadian
1151   1              OneTime[0].cdat[0] = 0xFF;              // mask bits (0's don't cares, 1's are matches)
1152   1              OneTime[0].cdat[1] = 0;
1153   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
1154   1              OneTime[0].cdat[3] = 0; // this byte matters
1155   1              OneTime[0].cdat[4] = 0;
1156   1              OneTime[0].cdat[5] = 0;  
1157   1              OneTime[0].cdat[6] = 0;
1158   1              OneTime[0].cdat[7] = 0;
1159   1              OneTime[1].cdat[0] = 0x0C;              // values (ORed)
1160   1              OneTime[1].cdat[1] = 0;
1161   1              OneTime[1].cdat[2] = 0;
1162   1              OneTime[1].cdat[3] = 0; // selector switches to x58 causes triggers
1163   1              OneTime[1].cdat[4] = 0;
1164   1              OneTime[1].cdat[5] = 0;
1165   1              OneTime[1].cdat[6] = 0;
1166   1              OneTime[1].cdat[7] = 0;
1167   1      // configure Rx filter, look for this message match
1168   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
1169   1              index = RxMessageConfig1(0,0x09E,OneTime[0].cdat,OneTime[1].cdat,8);
1170   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
1171   1              OneTime[0].cdat[1] = 0xFF;
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 20  

1172   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1173   1              OneTime[0].cdat[3] = 0xFF;
1174   1              OneTime[0].cdat[4] = 0xFF;
1175   1              OneTime[0].cdat[5] = 0xFF;
1176   1              OneTime[0].cdat[6] = 0xFF;
1177   1              OneTime[0].cdat[7] = 0xFF;
1178   1              OneTime[1].cdat[0] = 0x0C;      // values (ORed)
1179   1              OneTime[1].cdat[1] = 0;
1180   1              OneTime[1].cdat[2] = 0;
1181   1              OneTime[1].cdat[3] = 0;
1182   1              OneTime[1].cdat[4] = 0;
1183   1              OneTime[1].cdat[5] = 0;
1184   1              OneTime[1].cdat[6] = 0;
1185   1              OneTime[1].cdat[7] = 0;
1186   1      // configure Tx output caused by above Recieved message
1187   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
1188   1              RxMessageConfig2(index,0,0x5BC,OneTime[0].cdat,OneTime[1].cdat,8,0);
1189   1      
1190   1      //  Check for request to switch to Mexican
1191   1              OneTime[0].cdat[0] = 0xFF;              // mask bits (0's don't cares, 1's are matches)
1192   1              OneTime[0].cdat[1] = 0;
1193   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
1194   1              OneTime[0].cdat[3] = 0; // this byte matters
1195   1              OneTime[0].cdat[4] = 0;
1196   1              OneTime[0].cdat[5] = 0;  
1197   1              OneTime[0].cdat[6] = 0;
1198   1              OneTime[0].cdat[7] = 0;
1199   1              OneTime[1].cdat[0] = 0x0A;              // values (ORed)
1200   1              OneTime[1].cdat[1] = 0;
1201   1              OneTime[1].cdat[2] = 0;
1202   1              OneTime[1].cdat[3] = 0; // selector switches to x58 causes triggers
1203   1              OneTime[1].cdat[4] = 0;
1204   1              OneTime[1].cdat[5] = 0;
1205   1              OneTime[1].cdat[6] = 0;
1206   1              OneTime[1].cdat[7] = 0;
1207   1      // configure Rx filter, look for this message match
1208   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
1209   1              index = RxMessageConfig1(0,0x09E,OneTime[0].cdat,OneTime[1].cdat,8);
1210   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
1211   1              OneTime[0].cdat[1] = 0xFF;
1212   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1213   1              OneTime[0].cdat[3] = 0xFF;
1214   1              OneTime[0].cdat[4] = 0xFF;
1215   1              OneTime[0].cdat[5] = 0xFF;
1216   1              OneTime[0].cdat[6] = 0xFF;
1217   1              OneTime[0].cdat[7] = 0xFF;
1218   1              OneTime[1].cdat[0] = 0x0A;      // values (ORed)
1219   1              OneTime[1].cdat[1] = 0;
1220   1              OneTime[1].cdat[2] = 0;
1221   1              OneTime[1].cdat[3] = 0;
1222   1              OneTime[1].cdat[4] = 0;
1223   1              OneTime[1].cdat[5] = 0;
1224   1              OneTime[1].cdat[6] = 0;
1225   1              OneTime[1].cdat[7] = 0;
1226   1      // configure Tx output caused by above Recieved message
1227   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
1228   1              RxMessageConfig2(index,0,0x5BC,OneTime[0].cdat,OneTime[1].cdat,8,0);
1229   1      
1230   1      
1231   1      
1232   1      
1233   1      
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 21  

1234   1              // Configure Relay's
1235   1              RelayCnf[3] = REL_IGN | 1 | REL_NOT;    // relay 4 comes on with Ignition switch setting not 1
1236   1      //      RelayCnf[2] = REL_BUTT | 1 | REL_TOG;   // relay 3 toggles with button 1
1237   1      //      RelayCnf[1] = REL_RX | 0 | REL_PULSE;   // relay 2 with first (0) rxtrap configured
1238   1      //      RelayCnf[0] = REL_TX | 3 | REL_PULSE;   // relay 1 with 4th (3) TxMesg configured
1239   1      
1240   1      /*************************************************************************
1241   1              User running loop 
1242   1      **************************************************************************/
1243   1              cnt = 0;
1244   1              counter =0;
1245   1              while(!(keyChange & 0xF)) 
1246   1              {
1247   2                      if (RxCAN0)             // new message to process
1248   2                      {
1249   3                              for (index = 1 ; index < RX0BUFFERS && rxframe0[index].MsgNum>=RX0BUFFERS ; index++);
1250   3      
1251   3                              if (index < RX0BUFFERS)
1252   3                              {
1253   4                                      ProcessRx(0,index);
1254   4                                      rxframe0[index].MsgNum = 0;
1255   4                              }
1256   3                              RxCAN0 = 0;
1257   3                      }
1258   2                      if (RxCAN1)             // new message to process
1259   2                      {
1260   3                              error = CAN1readStatus();
1261   3      
1262   3                              index = RX1BUFFERS;
1263   3                              index1 = RX1BUFFERS;
1264   3                              if (error & MCP_RX1IF)
1265   3                                      index1 = CAN1read_canMsg( MCP_READ_RX1 );        
1266   3                              if (error & MCP_RX0IF)
1267   3                                      index = CAN1read_canMsg( MCP_READ_RX0 );        
1268   3                              if (error = CAN1readRegister(MCP_EFLG))
1269   3                              {
1270   4                                      ErrCnt++;
1271   4                                      AlterMessageByte(1,0x6E2,7,1,ErrCnt,0);
1272   4      
1273   4                                      if (error & MCP_EFLG_RX1OVR)
1274   4                                              CAN1modifyRegister(MCP_EFLG,MCP_EFLG_RX1OVR,0);
1275   4                                      if (error & MCP_EFLG_RX0OVR)
1276   4                                              CAN1modifyRegister(MCP_EFLG,MCP_EFLG_RX0OVR,0);
1277   4                              }
1278   3      
1279   3                              // clear int flags
1280   3                              IE0 = 0;                                        // clear IE0 flag re-enabling interupt
1281   3                              RxCAN1 = 0;                                     // clear my flag interupt occured
1282   3                              EX0 = 1;                                        // enable CAN1 interupt
1283   3      
1284   3                              if (index < RX1BUFFERS)                         // process recieved message from Rx0
1285   3                              {
1286   4                                      ProcessRx(1,index);             // CAN1 messages
1287   4                              }
1288   3                              if (index1 < RX1BUFFERS)                        // process recieved message from Rx1
1289   3                              {
1290   4                                      ProcessRx(1,index1);
1291   4                              }
1292   3                      }
1293   2      
1294   2                      if (StartTicks + ONESEC < msticks )     // every second
1295   2                      {
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 22  

1296   3                              StartTicks = msticks;
1297   3                              LED1 ^= 1;
1298   3      
1299   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
1300   3                              if (index1 < TXBUFFS)                           // empty one time available
1301   3                              {
1302   4                                      OneTime[index1].cdat[0] = (U8)(keys>>24);
1303   4                                      OneTime[index1].cdat[1] = (U8)(keys>>16);
1304   4                                      OneTime[index1].cdat[2] = (U8)(keys>>8);
1305   4                                      OneTime[index1].cdat[3] = (U8)keys;
1306   4                                      OneTime[index1].cdat[4] = CAN1readStatus();
1307   4                                      OneTime[index1].cdat[5] = CAN1readRxStat();
1308   4                                      OneTime[index1].cdat[6] = CAN1readRegister(MCP_CANSTAT);
1309   4                                      OneTime[index1].cdat[7] = CAN1readRegister(MCP_CANINTF);
1310   4                                      AlterMessageByte(0,0x6EA,0,OneTime[index1].cdat,8,1);
1311   4                              }
1312   3      
1313   3                              // VIN
1314   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
1315   3                              if (index1 < TXBUFFS)                           // empty one time available
1316   3                              {
1317   4                                      switch (vin++)
1318   4                                      {
1319   5                                              case 0:
1320   5                                                      OneTime[index1].cdat[0] = 0;
1321   5                                                      for (index = 0 ; index < 7 ; index++)
1322   5                                                              OneTime[index1].cdat[1+index] = VIN[index];
1323   5                                                      break;
1324   5                                              case 1:
1325   5                                                      OneTime[index1].cdat[0] = 1;
1326   5                                                      for (index = 7 ; index < 14 ; index++)
1327   5                                                              OneTime[index1].cdat[index-6] = VIN[index];
1328   5                                                      break;
1329   5                                              case 2:
1330   5                                                      OneTime[index1].cdat[0] = 2;
1331   5                                                      for (index = 14 ; index < 21 ; index++)
1332   5                                                              OneTime[index1].cdat[index-13] = VIN[index];
1333   5                                                      vin = 0;
1334   5                                                      break;
1335   5                                      }
1336   4                                      AlterMessageByte(0,0x3E0,0,OneTime[index1].cdat,8,0);
1337   4                              }
1338   3      
1339   3                              if (counter++ >= 9)     // test every 10 seconds alter 6E2 message
1340   3                              {
1341   4                                      for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
1342   4                                      if (index1 < TXBUFFS)                           // empty one time available
1343   4                                      {
1344   5                                              OneTime[index1].cdat[0] = cnt++;
1345   5                                              AlterMessageByte(1,0x6E2,6,OneTime[index1].cdat,1,2);
1346   5                                              counter = 0;
1347   5                                      }
1348   4                              }
1349   3                      }
1350   2      
1351   2      
1352   2                      if (RelayChange)
1353   2                              CheckRelay();
1354   2      
1355   2                      // check for buttons pressed and process
1356   2                      if (keyChange & 0xFFFFF00)      // At least one Buttons changed state
1357   2                      {
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 23  

1358   3                              CheckButts();                   // SimpleButton Check
1359   3      
1360   3                              keyChange &= (U32)((BUTTONMASK<<8)&0xFF);       // clear unused buttons
1361   3                      }
1362   2      
1363   2      
1364   2                      if (keyChange & 0xF0)           // Ignition change
1365   2                      {
1366   3                              // check if a relay is set to Ignition change
1367   3                              for (index1 = 0 ; index1 < 4; index1++){
1368   4                                      if ((RelayCnf[index1] & 0xF00) == REL_IGN)      // Relay controled by IGN select
1369   4                                      {
1370   5                                              if ((RelayCnf[index1]&0xFF) == ((keys>>4)&0xF)) // matching Select
1371   5                                                      RelayChange |= 1<<index1;                       // flag for relay "on" change
1372   5                                              else
1373   5                                                      RelayChange |= 0x10<<index1;            // flag for relay "off" change
1374   5                                      }
1375   4                              }
1376   3      
1377   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
1378   3                              if (index1 < TXBUFFS)                           // empty one time available
1379   3                              {
1380   4                                      IGN_OFF = 0;                    // default IGN_OFF flag to off
1381   4                                      switch(keys & 0xF0)
1382   4                                      {
1383   5                                              case 0x10:      // IGN_OFF
1384   5                                                      // ID 356, alter byte 2 
1385   5                                                      
1386   5                                                      OneTime[0].cdat[0] = 0;
1387   5                                                      OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
1388   5                                                      OneTime[0].cdat[2] = 0x20;
1389   5                                                      OneTime[0].cdat[3] = 0;
1390   5                                                      OneTime[0].cdat[4] = 0;
1391   5                                                      OneTime[0].cdat[5] = 0;
1392   5                                                      OneTime[0].cdat[6] = 0;
1393   5                                                      OneTime[0].cdat[7] = 0;
1394   5                                                      OneTime[0].sz = 8;
1395   5                                                      OneTime[0].arbID = 0x356 | 0;
1396   5      
1397   5                                                      OneTime[0].cdat[0] = 0;
1398   5                                                      OneTime[0].cdat[1] = 0x20;      // using OneTime structure as temp storage
1399   5                                                      OneTime[0].cdat[2] = 0x69;
1400   5                                                      OneTime[0].cdat[3] = 0x2F;
1401   5                                                      OneTime[0].cdat[4] = 0;
1402   5                                                      OneTime[0].cdat[5] = 0;
1403   5                                                      OneTime[0].cdat[6] = 0;
1404   5                                                      OneTime[0].cdat[7] = 0x02;
1405   5                                                      OneTime[0].sz = 8;
1406   5                                                      OneTime[0].arbID = 0x46C | 0;
1407   5                                                      
1408   5                                                                      
1409   5      //                                              OneTime[index1].cdat[0] = 0;
1410   5      //                                              OneTime[index1].cdat[1] = 0;
1411   5      //                                              OneTime[index1].cdat[2] = 0x20; 
1412   5      /*                                              OneTime[index1].cdat[3] = 0;
1413   5                                                      OneTime[index1].cdat[4] = 0;
1414   5                                                      OneTime[index1].cdat[5] = 0;
1415   5                                                      OneTime[index1].cdat[6] = 0;
1416   5                                                      OneTime[index1].cdat[7] = 0; */         
1417   5      //                                              AlterMessageByte(0,0x356,0,OneTime[index1].cdat,3,0); 
1418   5      
1419   5                                                      // ID 46C, alter byte 2  
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 24  

1420   5      //                                              OneTime[index1].cdat[0] = 0;                    
1421   5      //                                              OneTime[index1].cdat[1] = 0x20;
1422   5      /*                                              OneTime[index1].cdat[2] = 0xFF;
1423   5                                                      OneTime[index1].cdat[3] = 0xFF;
1424   5                                                      OneTime[index1].cdat[4] = 0xC0;
1425   5                                                      OneTime[index1].cdat[5] = 0x14;
1426   5                                                      OneTime[index1].cdat[6] = 0;
1427   5                                                      OneTime[index1].cdat[7] = 0; */
1428   5      //                                              AlterMessageByte(0,0x46C,0,OneTime[index1].cdat,2,0); */
1429   5                                                      IGN_OFF = 1;    // TURN on IGN_OFF flag
1430   5                                                      IGN_OFF_FLG= 0;
1431   5                                                      break;
1432   5                                              case 0x20:      // IGN_ACC
1433   5                                                              // ID 356, alter byte 2
1434   5                                                      OneTime[index1].cdat[0] = 0;
1435   5                                                      OneTime[index1].cdat[1] = 0;                    
1436   5                                                      OneTime[index1].cdat[2] = 0x30;
1437   5      /*                                              OneTime[index1].cdat[3] = 0;
1438   5                                                      OneTime[index1].cdat[4] = 0;
1439   5                                                      OneTime[index1].cdat[5] = 0;
1440   5                                                      OneTime[index1].cdat[6] = 0;
1441   5                                                      OneTime[index1].cdat[7] = 0; */                 
1442   5                                                      AlterMessageByte(0,0x356,0,OneTime[index1].cdat,3,0);
1443   5      
1444   5                                                      // ID 46C, alter byte 2  
1445   5                                                      OneTime[index1].cdat[0] = 0;                    
1446   5                                                      OneTime[index1].cdat[1] = 0x60;
1447   5      /*                                              OneTime[index1].cdat[2] = 0xFF;
1448   5                                                      OneTime[index1].cdat[3] = 0xFF;
1449   5                                                      OneTime[index1].cdat[4] = 0xC0;
1450   5                                                      OneTime[index1].cdat[5] = 0x14;
1451   5                                                      OneTime[index1].cdat[6] = 0;
1452   5                                                      OneTime[index1].cdat[7] = 0; */
1453   5                                                      AlterMessageByte(0,0x46C,0,OneTime[index1].cdat,2,0);
1454   5                                                      IGN_OFF_FLG = 1;
1455   5                                                      break;
1456   5      
1457   5                                              case 0x30:      // IGN_START
1458   5                                                      // ID 356, alter byte 2
1459   5                                                      OneTime[index1].cdat[0] = 0;
1460   5                                                      OneTime[index1].cdat[1] = 0;                    
1461   5                                                      OneTime[index1].cdat[2] = 0x60;
1462   5      /*                                              OneTime[index1].cdat[3] = 0;
1463   5                                                      OneTime[index1].cdat[4] = 0;
1464   5                                                      OneTime[index1].cdat[5] = 0;
1465   5                                                      OneTime[index1].cdat[6] = 0;
1466   5                                                      OneTime[index1].cdat[7] = 0; */                 
1467   5                                                      AlterMessageByte(0,0x356,0,OneTime[index1].cdat,3,0);
1468   5      
1469   5                                                      // ID 46C, alter byte 2  
1470   5                                                      OneTime[index1].cdat[0] = 0;                    
1471   5                                                      OneTime[index1].cdat[1] = 0xA0;
1472   5      /*                                              OneTime[index1].cdat[2] = 0xFF;
1473   5                                                      OneTime[index1].cdat[3] = 0xFF;
1474   5                                                      OneTime[index1].cdat[4] = 0xC0;
1475   5                                                      OneTime[index1].cdat[5] = 0x14;
1476   5                                                      OneTime[index1].cdat[6] = 0;
1477   5                                                      OneTime[index1].cdat[7] = 0; */
1478   5                                                      AlterMessageByte(0,0x46C,0,OneTime[index1].cdat,2,0);
1479   5                                                      IGN_OFF_FLG = 1;
1480   5                                                      break;
1481   5      
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 25  

1482   5                                                      
1483   5                                              case 0x40:      // IGN_RUN_0
1484   5                                                      // ID 356, alter byte 2
1485   5                                                      OneTime[index1].cdat[0] = 0;
1486   5                                                      OneTime[index1].cdat[1] = 0;                    
1487   5                                                      OneTime[index1].cdat[2] = 0x80; 
1488   5      /*                                              OneTime[index1].cdat[3] = 0;
1489   5                                                      OneTime[index1].cdat[4] = 0;
1490   5                                                      OneTime[index1].cdat[5] = 0;
1491   5                                                      OneTime[index1].cdat[6] = 0;
1492   5                                                      OneTime[index1].cdat[7] = 0;      */    
1493   5                                                      AlterMessageByte(0,0x356,0,OneTime[index1].cdat,3,0);
1494   5      
1495   5                                                      // ID 46C, alter byte 2  
1496   5                                                      OneTime[index1].cdat[0] = 0;                    
1497   5                                                      OneTime[index1].cdat[1] = 0x80;
1498   5      /*                                              OneTime[index1].cdat[2] = 0xFF;
1499   5                                                      OneTime[index1].cdat[3] = 0xFF;
1500   5                                                      OneTime[index1].cdat[4] = 0xC0;
1501   5                                                      OneTime[index1].cdat[5] = 0x14;
1502   5                                                      OneTime[index1].cdat[6] = 0;
1503   5                                                      OneTime[index1].cdat[7] = 0; */
1504   5                                                      AlterMessageByte(0,0x46C,0,OneTime[index1].cdat,2,0);
1505   5      
1506   5                                                      /// STATUS_CCAN5
1507   5                                                      OneTime[0].cdat[0] = 0;
1508   5                                                      OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
1509   5                                                      OneTime[0].cdat[2] = 0;
1510   5                                                      OneTime[0].cdat[3] = 0;
1511   5                                                      OneTime[0].cdat[4] = 0;
1512   5                                                      OneTime[0].cdat[5] = 0;
1513   5                                                      OneTime[0].cdat[6] = 0;
1514   5                                                      OneTime[0].cdat[7] = 0x02;
1515   5                                                      AlterMessageByte(0,0x3E2,0,OneTime[index1].cdat,8,0);
1516   5      
1517   5                                                      IGN_OFF_FLG = 1;
1518   5                                                      break;
1519   5      
1520   5                                              case 0x50:      // IGN_RUN_5
1521   5                                                      // ID 356, alter byte 2
1522   5                                                      OneTime[index1].cdat[0] = 0;
1523   5                                                      OneTime[index1].cdat[1] = 0;                    
1524   5                                                      OneTime[index1].cdat[2] = 0x80;                 
1525   5      /*                                              OneTime[index1].cdat[3] = 0;
1526   5                                                      OneTime[index1].cdat[4] = 0;
1527   5                                                      OneTime[index1].cdat[5] = 0;
1528   5                                                      OneTime[index1].cdat[6] = 0;
1529   5                                                      OneTime[index1].cdat[7] = 0; */
1530   5                                                      AlterMessageByte(0,0x356,0,OneTime[index1].cdat,3,0);
1531   5      
1532   5                                                      // ID 46C, alter byte 2
1533   5                                                      OneTime[index1].cdat[0] = 0;                    
1534   5                                                      OneTime[index1].cdat[1] = 0x80;
1535   5      /*                                              OneTime[index1].cdat[2] = 0xFF;
1536   5                                                      OneTime[index1].cdat[3] = 0xFF;
1537   5                                                      OneTime[index1].cdat[4] = 0xC0;
1538   5                                                      OneTime[index1].cdat[5] = 0x14;
1539   5                                                      OneTime[index1].cdat[6] = 0;
1540   5                                                      OneTime[index1].cdat[7] = 0; */
1541   5                                                      AlterMessageByte(0,0x46C,0,OneTime[index1].cdat,2,0);
1542   5      
1543   5                                                      /// STATUS_CCAN5
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 26  

1544   5                                                      OneTime[0].cdat[0] = 0;
1545   5                                                      OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
1546   5                                                      OneTime[0].cdat[2] = 0;
1547   5                                                      OneTime[0].cdat[3] = 0;
1548   5                                                      OneTime[0].cdat[4] = 0;
1549   5                                                      OneTime[0].cdat[5] = 0x04;
1550   5                                                      OneTime[0].cdat[6] = 0x08;
1551   5                                                      OneTime[0].cdat[7] = 0x02;
1552   5                                                      AlterMessageByte(0,0x3E2,0,OneTime[index1].cdat,8,0);
1553   5      
1554   5                                                      IGN_OFF_FLG = 1;
1555   5                                                      break;
1556   5                                              case 0x60:      // IGN_RUN_10
1557   5                                                      // ID 356, alter byte 2
1558   5                                                      OneTime[index1].cdat[0] = 0;
1559   5                                                      OneTime[index1].cdat[1] = 0;                    
1560   5                                                      OneTime[index1].cdat[2] = 0x80;          
1561   5      /*                                              OneTime[index1].cdat[3] = 0;
1562   5                                                      OneTime[index1].cdat[4] = 0;
1563   5                                                      OneTime[index1].cdat[5] = 0;
1564   5                                                      OneTime[index1].cdat[6] = 0;
1565   5                                                      OneTime[index1].cdat[7] = 0;    */
1566   5                                                      AlterMessageByte(0,0x356,0,OneTime[index1].cdat,3,0);
1567   5      
1568   5                                                      // ID 46C, alter byte 2 
1569   5                                                      OneTime[index1].cdat[0] = 0;                    
1570   5                                                      OneTime[index1].cdat[1] = 0x80;
1571   5      /*                                              OneTime[index1].cdat[2] = 0xFF;
1572   5                                                      OneTime[index1].cdat[3] = 0xFF;
1573   5                                                      OneTime[index1].cdat[4] = 0xC0;
1574   5                                                      OneTime[index1].cdat[5] = 0x14;
1575   5                                                      OneTime[index1].cdat[6] = 0;
1576   5                                                      OneTime[index1].cdat[7] = 0;    */
1577   5                                                      AlterMessageByte(0,0x46C,0,OneTime[index1].cdat,2,0);
1578   5      
1579   5                                                      /// STATUS_CCAN5
1580   5                                                      OneTime[0].cdat[0] = 0;
1581   5                                                      OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
1582   5                                                      OneTime[0].cdat[2] = 0;
1583   5                                                      OneTime[0].cdat[3] = 0;
1584   5                                                      OneTime[0].cdat[4] = 0;
1585   5                                                      OneTime[0].cdat[5] = 0x08;
1586   5                                                      OneTime[0].cdat[6] = 0x08;
1587   5                                                      OneTime[0].cdat[7] = 0x02;
1588   5                                                      AlterMessageByte(0,0x3E2,0,OneTime[index1].cdat,8,0);
1589   5      
1590   5                                                      IGN_OFF_FLG = 1;
1591   5                                                      break;
1592   5                                              
1593   5                                              case 0x70:
1594   5                                                      break;
1595   5                                              case 0x80:
1596   5                                                      break;
1597   5                                      }
1598   4      
1599   4                              keyChange &= ~0xF0;             // clear Ignition nibble
1600   4                              }
1601   3                      }
1602   2              }
1603   1      }
1604          
1605          void User2()    // program select 4
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 27  

1606          {       
1607   1              U8 cnt=0;
1608   1      
1609   1              while(!(keyChange & 0xF))
1610   1              {
1611   2                      for (cnt = 0 ; cnt < 8 ; cnt++)
1612   2                      {
1613   3                              LED1 ^= 1;
1614   3                              mSecDelay(100);
1615   3                      }
1616   2              mSecDelay(1200);
1617   2              }
1618   1      }
1619          
1620          void User3()    // program select 4
1621          {       
1622   1              U8 cnt=0;
1623   1      
1624   1              while(!(keyChange & 0xF))
1625   1              {
1626   2                      for (cnt = 0 ; cnt < 8 ; cnt++)
1627   2                      {
1628   3                              LED1 ^= 1;
1629   3                              mSecDelay(100);
1630   3                      }
1631   2              mSecDelay(1200);
1632   2              }
1633   1      }
1634          
1635          void User4()    // program select 4
1636          {       
1637   1              U8 cnt=0;
1638   1      
1639   1              while(!(keyChange & 0xF))
1640   1              {
1641   2                      for (cnt = 0 ; cnt < 8 ; cnt++)
1642   2                      {
1643   3                              LED1 ^= 1;
1644   3                              mSecDelay(100);
1645   3                      }
1646   2              mSecDelay(1200);
1647   2              }
1648   1      }
1649          void User5()    // program select 5
1650          {       
1651   1              U8 cnt=0;
1652   1      
1653   1              while(!(keyChange & 0xF))
1654   1              {
1655   2                      for (cnt = 0 ; cnt < 10 ; cnt++)
1656   2                      {
1657   3                              LED1 ^= 1;
1658   3                              mSecDelay(100);
1659   3                      }
1660   2              mSecDelay(1000);
1661   2              }
1662   1      }
1663          void User6()    // program select 6
1664          {       
1665   1              U8 cnt=0;
1666   1      
1667   1              while(!(keyChange & 0xF))
C51 COMPILER V9.51   USER                                                                  09/23/2016 08:53:32 PAGE 28  

1668   1              {
1669   2                      for (cnt = 0 ; cnt < 12 ; cnt++)
1670   2                      {
1671   3                              LED1 ^= 1;
1672   3                              mSecDelay(100);
1673   3                      }
1674   2              mSecDelay(800);
1675   2              }
1676   1      }
1677          void User7()    // program select 7
1678          {       
1679   1              U8 cnt=0;
1680   1      
1681   1              while(!(keyChange & 0xF))
1682   1              {
1683   2                      for (cnt = 0 ; cnt < 14 ; cnt++)
1684   2                      {
1685   3                              LED1 ^= 1;
1686   3                              mSecDelay(100);
1687   3                      }
1688   2              mSecDelay(600);
1689   2              }
1690   1      }
1691          
1692          void User8(void)        // example program select 8
1693          {
1694   1      }
1695          
1696          
1697          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6296    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
