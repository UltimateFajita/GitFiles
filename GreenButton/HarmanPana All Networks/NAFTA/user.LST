C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USER
OBJECT MODULE PLACED IN user.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe user.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          //Can Bus Simulator
   2          #include "c8051F040.h"
   3          #include "stdlib.h"
   4          #include "string.h"
   5          #include "stdio.h"
   6          #include "main.h"
   7          #include "spi.h"
   8          
   9          extern CANFRAME xdata OneTime[TXBUFFS];
  10          extern CANFRAME xdata rxframe0[RX0BUFFERS];
  11          extern U8 xdata MaxMesgs,MaxRxTraps;
  12          
  13          extern MSGTABLE xdata *Mesgs;
  14          extern U8 xdata MesgCnt;
  15          extern BUTTABLE xdata *Buttons;
  16          extern U8 xdata ButtCnt;
  17          extern RxMESG xdata *RxMesg;
  18          extern U8 xdata RxCnt;
  19          extern U16 xdata RelayCnf[4];
  20          extern U8 xdata RelayChange;
  21          extern U8 xdata RxBuffCnt[2];
  22          
  23          extern bit IGN_OFF_FLG;
  24          
  25          extern U32 keys,keyChange;
  26          extern bit RxCAN0,RxCAN1;
  27          extern U32 msticks;
  28          
  29          void User1()    // program select 1 - CUSW
  30          {       
  31   1              U32 StartTicks = 0;
  32   1              U8  index,index1,ErrCnt,counter,vin,error, cnt;
  33   1              bit IGN_OFF=1;
  34   1      
  35   1              char VIN[17] = "1C3ADECZ7GV1002UC";
  36   1      
  37   1              error = 0;      ErrCnt=0;
  38   1      
  39   1      
  40   1      
  41   1      /***************************************************************************************
  42   1      ****************************************************************************************
  43   1              CAUTION WATCH XDATA BOUNDARIES.  NOT AUTOMATIC ITS UP TO YOU!!!!!!
  44   1      ****************************************************************************************
  45   1              // CODE CURRENTLY USES 809 xdata bytes.  THEREFORE STARTING CAN BE AT 0x32A
  46   1              // watch at compile the xdata bytes used. if xdata > 810d need to change below
  47   1              // xdata space ends at 0xFFF.
  48   1      ***************************************************************************************/
  49   1      //      Buttons = (BUTTABLE xdata *)0x32A;      // 20 buttons takes 32Abytes => 0x32A-0x4E1
  50   1              ButtCnt = 0;                                            // each Button = 20 bytes
  51   1      
  52   1      //      Mesgs = (MSGTABLE xdata *)0x4E2;        // 0x4E2-0x93F -> space for 43 Tx messages 
  53   1              MesgCnt = 0;                                            // each Mesgs = 26 bytes
  54   1      
  55   1      //      RxMesg = (RxMESG xdata *)0x940;         // 0x940-0xFF8 -> space for 43 Rx messages 
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 2   

  56   1              RxCnt = 0;                                                      // each RxMesg = 40 bytes
  57   1      
  58   1      // AUTOMATED above some,
  59   1      // Make Sure XDATASPACE define follows compile output value  
  60   1      #define XDATASPACE 810          // starting free address
  61   1      
  62   1      /***************************************************************************************
  63   1      // Currently (809 xdata start) you get 43 Tx messages and 43 Rx message traps.  If you 
  64   1      // need more of one and less of the other you can manipulate the starting numbers below
  65   1      // to get it to work.
  66   1      // also note RX0 buff size is 32 messages on CAN0, and RX1 buff size is 16 for CAN1
  67   1      ***************************************************************************************/
  68   1              MaxMesgs = 45;                  // number of Tx message configs
  69   1              MaxRxTraps = 45;                // number of Rx message configs
  70   1              while(!MemManage(MAXBUTTONS,MaxMesgs,MaxRxTraps,XDATASPACE))    // 20 button configs  
  71   1              {
  72   2                      MaxRxTraps--;           // reduce Message buffers till it fits.
  73   2                      if (!MemManage(MAXBUTTONS,MaxMesgs,MaxRxTraps,XDATASPACE))
  74   2                              MaxMesgs--;             // reduce Message buffers till it fits
  75   2              }
  76   1      /**************************************************************************************/
  77   1      
  78   1      
  79   1      /*************************************************************************
  80   1              Repeating message setups
  81   1              example below-
  82   1              message ID 0x6E2 is created at rate of 500mSec on port 1 (C). With 8 bytes 
  83   1              of data, shown are it's defaults.
  84   1      **************************************************************************/
  85   1              // build repetative message 6E2 on CAN1
  86   1              OneTime[0].cdat[0] = 0;
  87   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
  88   1              OneTime[0].cdat[2] = 0;
  89   1              OneTime[0].cdat[3] = 0;
  90   1              OneTime[0].cdat[4] = 0;
  91   1              OneTime[0].cdat[5] = 0;
  92   1              OneTime[0].cdat[6] = 0;
  93   1              OneTime[0].cdat[7] = 0;
  94   1      //U8 AddMessage(U8 port,U32 ID,U16 Rate,U8 cnt,U8 dat[8])
  95   1              AddMessage(0,0x339,500,8,OneTime[0].cdat);
  96   1      
  97   1              // build repetative message 3E0 on CAN0 
  98   1              vin = 0;
  99   1              OneTime[0].cdat[0] = 0;
 100   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 101   1              OneTime[0].cdat[2] = 0;
 102   1              OneTime[0].cdat[3] = 0;
 103   1              OneTime[0].cdat[4] = 0;
 104   1              OneTime[0].cdat[5] = 0;
 105   1              OneTime[0].cdat[6] = 0;
 106   1              OneTime[0].cdat[7] = 0;
 107   1              AddMessage(0,0x33B,50,8,OneTime[0].cdat);
 108   1      
 109   1              // build repetative message 46C on CAN0 
 110   1              OneTime[0].cdat[0] = 0;
 111   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 112   1              OneTime[0].cdat[2] = 0;
 113   1              OneTime[0].cdat[3] = 0;
 114   1              OneTime[0].cdat[4] = 0;
 115   1              OneTime[0].cdat[5] = 0;
 116   1              OneTime[0].cdat[6] = 0;
 117   1              OneTime[0].cdat[7] = 0;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 3   

 118   1              AddMessage(0,0x3CB,500,8,OneTime[0].cdat);
 119   1              
 120   1              OneTime[0].cdat[0] = 0;
 121   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 122   1              OneTime[0].cdat[2] = 0;
 123   1              OneTime[0].cdat[3] = 0;
 124   1              AddMessage(0,0x3D1,500,4,OneTime[0].cdat);
 125   1              
 126   1              OneTime[0].cdat[0] = 0;
 127   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 128   1              OneTime[0].cdat[2] = 0;
 129   1              OneTime[0].cdat[3] = 0;
 130   1              OneTime[0].cdat[4] = 0;
 131   1              OneTime[0].cdat[5] = 0;
 132   1              OneTime[0].cdat[6] = 0;
 133   1              OneTime[0].cdat[7] = 0;
 134   1              AddMessage(0,0x3D3,500,8,OneTime[0].cdat);
 135   1              
 136   1              OneTime[0].cdat[0] = 0;
 137   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 138   1              OneTime[0].cdat[2] = 0;
 139   1              OneTime[0].cdat[3] = 0x05;
 140   1              OneTime[0].cdat[4] = 0;
 141   1              AddMessage(0,0x499,500,5,OneTime[0].cdat);
 142   1              
 143   1              OneTime[0].cdat[0] = 0;
 144   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 145   1              OneTime[0].cdat[2] = 0;
 146   1              OneTime[0].cdat[3] = 0;
 147   1              OneTime[0].cdat[4] = 0;
 148   1              OneTime[0].cdat[5] = 0;
 149   1              OneTime[0].cdat[6] = 0;
 150   1              OneTime[0].cdat[7] = 0;
 151   1              AddMessage(0,0x4A3,500,8,OneTime[0].cdat);
 152   1              
 153   1              OneTime[0].cdat[0] = 0;
 154   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 155   1              OneTime[0].cdat[2] = 0;
 156   1              OneTime[0].cdat[3] = 0;
 157   1              AddMessage(0,0x548,500,4,OneTime[0].cdat);
 158   1              
 159   1              OneTime[0].cdat[0] = 0;
 160   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 161   1              AddMessage(0,0x5C8,500,2,OneTime[0].cdat);
 162   1              
 163   1              OneTime[0].cdat[0] = 0xC8;
 164   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 165   1              OneTime[0].cdat[2] = 0xFF;
 166   1              OneTime[0].cdat[3] = 0xFF;
 167   1              OneTime[0].cdat[4] = 0xFF;
 168   1              OneTime[0].cdat[5] = 0xFF;
 169   1              OneTime[0].cdat[6] = 0;
 170   1              OneTime[0].cdat[7] = 0;
 171   1              AddMessage(0,0x5CA,500,8,OneTime[0].cdat);
 172   1              
 173   1              OneTime[0].cdat[0] = 0;
 174   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 175   1              OneTime[0].cdat[2] = 0;
 176   1              OneTime[0].cdat[3] = 0;
 177   1              AddMessage(0,0x5CC,500,4,OneTime[0].cdat);
 178   1              
 179   1              OneTime[0].cdat[0] = 0;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 4   

 180   1              OneTime[0].cdat[1] = 0x20;      // using OneTime structure as temp storage
 181   1              OneTime[0].cdat[2] = 0;
 182   1              OneTime[0].cdat[3] = 0;
 183   1              OneTime[0].cdat[4] = 0;
 184   1              AddMessage(0,0x5DC,500,5,OneTime[0].cdat);
 185   1              
 186   1              OneTime[0].cdat[0] = 0;
 187   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 188   1              OneTime[0].cdat[2] = 0;
 189   1              OneTime[0].cdat[3] = 0;
 190   1              OneTime[0].cdat[4] = 0;
 191   1              OneTime[0].cdat[5] = 0;
 192   1              OneTime[0].cdat[6] = 0;
 193   1              OneTime[0].cdat[7] = 0;
 194   1              AddMessage(0,0x6A4,500,8,OneTime[0].cdat);
 195   1              
 196   1              OneTime[0].cdat[0] = 0;
 197   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 198   1              AddMessage(0,0x75A,500,2,OneTime[0].cdat);
 199   1              
 200   1              OneTime[0].cdat[0] = 0x0F;
 201   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 202   1              OneTime[0].cdat[2] = 0;
 203   1              AddMessage(0,0x762,500,3,OneTime[0].cdat);
 204   1              
 205   1              OneTime[0].cdat[0] = 0;
 206   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 207   1              OneTime[0].cdat[2] = 0;
 208   1              OneTime[0].cdat[3] = 0;
 209   1              AddMessage(0,0x772,500,4,OneTime[0].cdat);
 210   1      
 211   1                      // build repetative message 6EA on CAN0
 212   1              OneTime[0].cdat[0] = 0;
 213   1              OneTime[0].cdat[1] = 0x22;      // using OneTime structure as temp storage
 214   1              OneTime[0].cdat[0] = 0;
 215   1              OneTime[0].cdat[1] = 0;
 216   1              OneTime[0].cdat[1] = 0;
 217   1              AddMessage(0,0x190,1000,5,OneTime[0].cdat);
 218   1      
 219   1                      // build repetative message 6EA on CAN0
 220   1              OneTime[0].cdat[0] = 0;
 221   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 222   1              OneTime[0].cdat[2] = 0;
 223   1              OneTime[0].cdat[3] = 0;
 224   1              OneTime[0].cdat[4] = 0;
 225   1              OneTime[0].cdat[5] = 0;
 226   1              OneTime[0].cdat[6] = 0;
 227   1              OneTime[0].cdat[7] = 0;
 228   1              AddMessage(0,0x098,1000,8,OneTime[0].cdat);
 229   1              
 230   1              
 231   1              OneTime[0].cdat[0] = 0;
 232   1              OneTime[0].cdat[1] = 0x02;      // using OneTime structure as temp storage
 233   1              OneTime[0].cdat[2] = 0;
 234   1              OneTime[0].cdat[3] = 0;
 235   1              OneTime[0].cdat[4] = 0;
 236   1              OneTime[0].cdat[5] = 0;
 237   1              AddMessage(0,0xE094000,500,6,OneTime[0].cdat);
 238   1              
 239   1              OneTime[0].cdat[0] = 0;
 240   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 241   1              OneTime[0].cdat[2] = 0;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 5   

 242   1              OneTime[0].cdat[3] = 0;
 243   1              OneTime[0].cdat[4] = 0;
 244   1              OneTime[0].cdat[5] = 0;
 245   1              OneTime[0].cdat[6] = 0;
 246   1              OneTime[0].cdat[7] = 0;
 247   1              AddMessage(0,0x5E0,500,8,OneTime[0].cdat);
 248   1              
 249   1              OneTime[0].cdat[0] = 0;
 250   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 251   1              OneTime[0].cdat[2] = 0;
 252   1              OneTime[0].cdat[3] = 0;
 253   1              OneTime[0].cdat[4] = 0;
 254   1              OneTime[0].cdat[5] = 0;
 255   1              OneTime[0].cdat[6] = 0;
 256   1              OneTime[0].cdat[7] = 0;
 257   1              AddMessage(0,0x5E2,500,8,OneTime[0].cdat);
 258   1      
 259   1      /*************************************************************************
 260   1              Button setup
 261   1              example below -
 262   1              pressing button 1 causes byte 5 of message 0x6E2 to be altered to 0xAA 
 263   1              for the next 5 outputs. The mask clears byte 5 leaving the rest alone.  
 264   1              The value (0xAA) is ORed into byte 5.
 265   1      **************************************************************************/
 266   1              #define BUTTONMASK 0xF  // only button 1 defined (bit 1) 
 267   1      
 268   1              // Volume Up
 269   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 270   1              OneTime[0].cdat[1] = 0xFF;
 271   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 272   1              OneTime[0].cdat[3] = 0xFF;
 273   1              OneTime[0].cdat[4] = 0xFF;
 274   1              OneTime[0].cdat[5] = 0;         
 275   1              OneTime[0].cdat[6] = 0xFF;
 276   1              OneTime[0].cdat[7] = 0xFF;
 277   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 278   1              OneTime[1].cdat[1] = 0;
 279   1              OneTime[1].cdat[2] = 0;
 280   1              OneTime[1].cdat[3] = 0;
 281   1              OneTime[1].cdat[4] = 0;
 282   1              OneTime[1].cdat[5] = 0x08;
 283   1              OneTime[1].cdat[6] = 0;
 284   1              OneTime[1].cdat[7] = 0;
 285   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 286   1              SimpleButtonConfig(19,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 287   1      
 288   1              // Volume Down
 289   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 290   1              OneTime[0].cdat[1] = 0xFF;
 291   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 292   1              OneTime[0].cdat[3] = 0xFF;
 293   1              OneTime[0].cdat[4] = 0xFF;
 294   1              OneTime[0].cdat[5] = 0;         
 295   1              OneTime[0].cdat[6] = 0xFF;
 296   1              OneTime[0].cdat[7] = 0xFF;
 297   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 298   1              OneTime[1].cdat[1] = 0;
 299   1              OneTime[1].cdat[2] = 0;
 300   1              OneTime[1].cdat[3] = 0;
 301   1              OneTime[1].cdat[4] = 0;
 302   1              OneTime[1].cdat[5] = 0x20;
 303   1              OneTime[1].cdat[6] = 0;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 6   

 304   1              OneTime[1].cdat[7] = 0;
 305   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 306   1              SimpleButtonConfig(9,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 307   1      
 308   1              // Mode
 309   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 310   1              OneTime[0].cdat[1] = 0xFF;
 311   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 312   1              OneTime[0].cdat[3] = 0xFF;
 313   1              OneTime[0].cdat[4] = 0xFF;
 314   1              OneTime[0].cdat[5] = 0;         
 315   1              OneTime[0].cdat[6] = 0xFF;
 316   1              OneTime[0].cdat[7] = 0xFF;
 317   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 318   1              OneTime[1].cdat[1] = 0;
 319   1              OneTime[1].cdat[2] = 0;
 320   1              OneTime[1].cdat[3] = 0;
 321   1              OneTime[1].cdat[4] = 0;
 322   1              OneTime[1].cdat[5] = 0x80;
 323   1              OneTime[1].cdat[6] = 0;
 324   1              OneTime[1].cdat[7] = 0;
 325   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 326   1              SimpleButtonConfig(18,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 327   1      
 328   1              // Preset
 329   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 330   1              OneTime[0].cdat[1] = 0xFF;
 331   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 332   1              OneTime[0].cdat[3] = 0;
 333   1              OneTime[0].cdat[4] = 0xFF;
 334   1              OneTime[0].cdat[5] = 0xFF;              
 335   1              OneTime[0].cdat[6] = 0xFF;
 336   1              OneTime[0].cdat[7] = 0xFF;
 337   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 338   1              OneTime[1].cdat[1] = 0;
 339   1              OneTime[1].cdat[2] = 0;
 340   1              OneTime[1].cdat[3] = 0x08;
 341   1              OneTime[1].cdat[4] = 0;
 342   1              OneTime[1].cdat[5] = 0;
 343   1              OneTime[1].cdat[6] = 0;
 344   1              OneTime[1].cdat[7] = 0;
 345   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 346   1              SimpleButtonConfig(8,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 347   1      
 348   1              // Seek Up
 349   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 350   1              OneTime[0].cdat[1] = 0xFF;
 351   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 352   1              OneTime[0].cdat[3] = 0xFF;
 353   1              OneTime[0].cdat[4] = 0;
 354   1              OneTime[0].cdat[5] = 0xFF;              
 355   1              OneTime[0].cdat[6] = 0xFF;
 356   1              OneTime[0].cdat[7] = 0xFF;
 357   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 358   1              OneTime[1].cdat[1] = 0;
 359   1              OneTime[1].cdat[2] = 0;
 360   1              OneTime[1].cdat[3] = 0;
 361   1              OneTime[1].cdat[4] = 0x02;
 362   1              OneTime[1].cdat[5] = 0;
 363   1              OneTime[1].cdat[6] = 0;
 364   1              OneTime[1].cdat[7] = 0;
 365   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 7   

 366   1              SimpleButtonConfig(17,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 367   1      
 368   1              // Seek Down
 369   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 370   1              OneTime[0].cdat[1] = 0xFF;
 371   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 372   1              OneTime[0].cdat[3] = 0xFF;
 373   1              OneTime[0].cdat[4] = 0;
 374   1              OneTime[0].cdat[5] = 0xFF;              
 375   1              OneTime[0].cdat[6] = 0xFF;
 376   1              OneTime[0].cdat[7] = 0xFF;
 377   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 378   1              OneTime[1].cdat[1] = 0;
 379   1              OneTime[1].cdat[2] = 0;
 380   1              OneTime[1].cdat[3] = 0;
 381   1              OneTime[1].cdat[4] = 0x08;
 382   1              OneTime[1].cdat[5] = 0;
 383   1              OneTime[1].cdat[6] = 0;
 384   1              OneTime[1].cdat[7] = 0;
 385   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 386   1              SimpleButtonConfig(7,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 387   1      
 388   1              // Phone Pickup
 389   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 390   1              OneTime[0].cdat[1] = 0xFF;
 391   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 392   1              OneTime[0].cdat[3] = 0xFF;
 393   1              OneTime[0].cdat[4] = 0;
 394   1              OneTime[0].cdat[5] = 0xFF;              
 395   1              OneTime[0].cdat[6] = 0xFF;
 396   1              OneTime[0].cdat[7] = 0xFF;
 397   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 398   1              OneTime[1].cdat[1] = 0;
 399   1              OneTime[1].cdat[2] = 0;
 400   1              OneTime[1].cdat[3] = 0;
 401   1              OneTime[1].cdat[4] = 0x80;
 402   1              OneTime[1].cdat[5] = 0;
 403   1              OneTime[1].cdat[6] = 0;
 404   1              OneTime[1].cdat[7] = 0;
 405   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 406   1              SimpleButtonConfig(16,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 407   1      
 408   1              // Phone Hangup
 409   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 410   1              OneTime[0].cdat[1] = 0xFF;
 411   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 412   1              OneTime[0].cdat[3] = 0;
 413   1              OneTime[0].cdat[4] = 0xFF;
 414   1              OneTime[0].cdat[5] = 0xFF;              
 415   1              OneTime[0].cdat[6] = 0xFF;
 416   1              OneTime[0].cdat[7] = 0xFF;
 417   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 418   1              OneTime[1].cdat[1] = 0;
 419   1              OneTime[1].cdat[2] = 0;
 420   1              OneTime[1].cdat[3] = 0x02;
 421   1              OneTime[1].cdat[4] = 0;
 422   1              OneTime[1].cdat[5] = 0;
 423   1              OneTime[1].cdat[6] = 0;
 424   1              OneTime[1].cdat[7] = 0;
 425   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 426   1              SimpleButtonConfig(6,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 427   1      
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 8   

 428   1              // VR
 429   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 430   1              OneTime[0].cdat[1] = 0xFF;
 431   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 432   1              OneTime[0].cdat[3] = 0;
 433   1              OneTime[0].cdat[4] = 0xFF;
 434   1              OneTime[0].cdat[5] = 0xFF;              
 435   1              OneTime[0].cdat[6] = 0xFF;
 436   1              OneTime[0].cdat[7] = 0xFF;
 437   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 438   1              OneTime[1].cdat[1] = 0;
 439   1              OneTime[1].cdat[2] = 0;
 440   1              OneTime[1].cdat[3] = 0x20;
 441   1              OneTime[1].cdat[4] = 0;
 442   1              OneTime[1].cdat[5] = 0;
 443   1              OneTime[1].cdat[6] = 0;
 444   1              OneTime[1].cdat[7] = 0;
 445   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 446   1              SimpleButtonConfig(15,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 447   1      
 448   1              // Screen Off
 449   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 450   1              OneTime[0].cdat[1] = 0;
 451   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 452   1              OneTime[0].cdat[3] = 0xFF;
 453   1              OneTime[0].cdat[4] = 0xFF;
 454   1              OneTime[0].cdat[5] = 0xFF;              
 455   1              OneTime[0].cdat[6] = 0xFF;
 456   1              OneTime[0].cdat[7] = 0xFF;
 457   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 458   1              OneTime[1].cdat[1] = 0x10;
 459   1              OneTime[1].cdat[2] = 0;
 460   1              OneTime[1].cdat[3] = 0;
 461   1              OneTime[1].cdat[4] = 0;
 462   1              OneTime[1].cdat[5] = 0;
 463   1              OneTime[1].cdat[6] = 0;
 464   1              OneTime[1].cdat[7] = 0;
 465   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 466   1              SimpleButtonConfig(5,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
 467   1      
 468   1              // Mute
 469   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
 470   1              OneTime[0].cdat[1] = 0xFF;
 471   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 472   1              OneTime[0].cdat[3] = 0xFF;
 473   1              OneTime[0].cdat[4] = 0xFF;
 474   1              OneTime[0].cdat[5] = 0xFF;              
 475   1              OneTime[0].cdat[6] = 0xFF;
 476   1              OneTime[0].cdat[7] = 0xFF;
 477   1              OneTime[1].cdat[0] = 0x02;              // values (ORed)
 478   1              OneTime[1].cdat[1] = 0;
 479   1              OneTime[1].cdat[2] = 0;
 480   1              OneTime[1].cdat[3] = 0;
 481   1              OneTime[1].cdat[4] = 0;
 482   1              OneTime[1].cdat[5] = 0;
 483   1              OneTime[1].cdat[6] = 0;
 484   1              OneTime[1].cdat[7] = 0;
 485   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 486   1              SimpleButtonConfig(14,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
 487   1      
 488   1              // Back
 489   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 9   

 490   1              OneTime[0].cdat[1] = 0;
 491   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 492   1              OneTime[0].cdat[3] = 0xFF;
 493   1              OneTime[0].cdat[4] = 0xFF;
 494   1              OneTime[0].cdat[5] = 0xFF;              
 495   1              OneTime[0].cdat[6] = 0xFF;
 496   1              OneTime[0].cdat[7] = 0xFF;
 497   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 498   1              OneTime[1].cdat[1] = 0x01;
 499   1              OneTime[1].cdat[2] = 0;
 500   1              OneTime[1].cdat[3] = 0;
 501   1              OneTime[1].cdat[4] = 0;
 502   1              OneTime[1].cdat[5] = 0;
 503   1              OneTime[1].cdat[6] = 0;
 504   1              OneTime[1].cdat[7] = 0;
 505   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 506   1              SimpleButtonConfig(4,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
 507   1      
 508   1              // Browse/Enter
 509   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
 510   1              OneTime[0].cdat[1] = 0xFF;
 511   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 512   1              OneTime[0].cdat[3] = 0xFF;
 513   1              OneTime[0].cdat[4] = 0xFF;
 514   1              OneTime[0].cdat[5] = 0xFF;              
 515   1              OneTime[0].cdat[6] = 0xFF;
 516   1              OneTime[0].cdat[7] = 0xFF;
 517   1              OneTime[1].cdat[0] = 0x01;              // values (ORed)
 518   1              OneTime[1].cdat[1] = 0;
 519   1              OneTime[1].cdat[2] = 0;
 520   1              OneTime[1].cdat[3] = 0;
 521   1              OneTime[1].cdat[4] = 0;
 522   1              OneTime[1].cdat[5] = 0;
 523   1              OneTime[1].cdat[6] = 0;
 524   1              OneTime[1].cdat[7] = 0;
 525   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 526   1              SimpleButtonConfig(13,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
 527   1      
 528   1              // Screenshot
 529   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 530   1              OneTime[0].cdat[1] = 0xFF;
 531   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 532   1              OneTime[0].cdat[3] = 0xFF;
 533   1              OneTime[0].cdat[4] = 0;
 534   1              OneTime[0].cdat[5] = 0xFF;              
 535   1              OneTime[0].cdat[6] = 0xFF;
 536   1              OneTime[0].cdat[7] = 0xFF;
 537   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 538   1              OneTime[1].cdat[1] = 0;
 539   1              OneTime[1].cdat[2] = 0;
 540   1              OneTime[1].cdat[3] = 0;
 541   1              OneTime[1].cdat[4] = 0xC8;
 542   1              OneTime[1].cdat[5] = 0;
 543   1              OneTime[1].cdat[6] = 0;
 544   1              OneTime[1].cdat[7] = 0;
 545   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 546   1              SimpleButtonConfig(3,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,12);
 547   1      
 548   1      
 549   1              // ENG. Mode
 550   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 551   1              OneTime[0].cdat[1] = 0xFF;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 10  

 552   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 553   1              OneTime[0].cdat[3] = 0xFF;
 554   1              OneTime[0].cdat[4] = 0;
 555   1              OneTime[0].cdat[5] = 0xFF;              
 556   1              OneTime[0].cdat[6] = 0xFF;
 557   1              OneTime[0].cdat[7] = 0xFF;
 558   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 559   1              OneTime[1].cdat[1] = 0;
 560   1              OneTime[1].cdat[2] = 0;
 561   1              OneTime[1].cdat[3] = 0;
 562   1              OneTime[1].cdat[4] = 0xC0;
 563   1              OneTime[1].cdat[5] = 0;
 564   1              OneTime[1].cdat[6] = 0;
 565   1              OneTime[1].cdat[7] = 0;
 566   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 567   1              SimpleButtonConfig(12,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,12);
 568   1      
 569   1              // Dealer Mode
 570   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 571   1              OneTime[0].cdat[1] = 0xFF;
 572   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 573   1              OneTime[0].cdat[3] = 0xFF;
 574   1              OneTime[0].cdat[4] = 0;
 575   1              OneTime[0].cdat[5] = 0xFF;              
 576   1              OneTime[0].cdat[6] = 0xFF;
 577   1              OneTime[0].cdat[7] = 0xFF;
 578   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 579   1              OneTime[1].cdat[1] = 0;
 580   1              OneTime[1].cdat[2] = 0;
 581   1              OneTime[1].cdat[3] = 0;
 582   1              OneTime[1].cdat[4] = 0xC4;
 583   1              OneTime[1].cdat[5] = 0;
 584   1              OneTime[1].cdat[6] = 0;
 585   1              OneTime[1].cdat[7] = 0;
 586   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 587   1              SimpleButtonConfig(2,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,12);
 588   1      
 589   1      /*
 590   1              // 911
 591   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 592   1              OneTime[0].cdat[1] = 0xFF;
 593   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 594   1              OneTime[0].cdat[3] = 0xFF;
 595   1              OneTime[0].cdat[4] = 0;
 596   1              OneTime[0].cdat[5] = 0xFF;              
 597   1              OneTime[0].cdat[6] = 0xFF;
 598   1              OneTime[0].cdat[7] = 0xFF;
 599   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 600   1              OneTime[1].cdat[1] = 0;
 601   1              OneTime[1].cdat[2] = 0;
 602   1              OneTime[1].cdat[3] = 0;
 603   1              OneTime[1].cdat[4] = 0x80;
 604   1              OneTime[1].cdat[5] = 0;
 605   1              OneTime[1].cdat[6] = 0;
 606   1              OneTime[1].cdat[7] = 0;
 607   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 608   1              SimpleButtonConfig(11,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 609   1      
 610   1              // Assist
 611   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 612   1              OneTime[0].cdat[1] = 0xFF;
 613   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 11  

 614   1              OneTime[0].cdat[3] = 0xFF;
 615   1              OneTime[0].cdat[4] = 0;
 616   1              OneTime[0].cdat[5] = 0xFF;              
 617   1              OneTime[0].cdat[6] = 0xFF;
 618   1              OneTime[0].cdat[7] = 0xFF;
 619   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 620   1              OneTime[1].cdat[1] = 0;
 621   1              OneTime[1].cdat[2] = 0;
 622   1              OneTime[1].cdat[3] = 0;
 623   1              OneTime[1].cdat[4] = 0x80;
 624   1              OneTime[1].cdat[5] = 0;
 625   1              OneTime[1].cdat[6] = 0;
 626   1              OneTime[1].cdat[7] = 0;
 627   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 628   1              SimpleButtonConfig(1,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 629   1      
 630   1              // Door Ajar
 631   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 632   1              OneTime[0].cdat[1] = 0xFF;
 633   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 634   1              OneTime[0].cdat[3] = 0xFF;
 635   1              OneTime[0].cdat[4] = 0;
 636   1              OneTime[0].cdat[5] = 0xFF;              
 637   1              OneTime[0].cdat[6] = 0xFF;
 638   1              OneTime[0].cdat[7] = 0xFF;
 639   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 640   1              OneTime[1].cdat[1] = 0;
 641   1              OneTime[1].cdat[2] = 0;
 642   1              OneTime[1].cdat[3] = 0;
 643   1              OneTime[1].cdat[4] = 0x80;
 644   1              OneTime[1].cdat[5] = 0;
 645   1              OneTime[1].cdat[6] = 0;
 646   1              OneTime[1].cdat[7] = 0;
 647   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 648   1              SimpleButtonConfig(10,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 649   1      
 650   1              // Theft Alarm
 651   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 652   1              OneTime[0].cdat[1] = 0xFF;
 653   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 654   1              OneTime[0].cdat[3] = 0xFF;
 655   1              OneTime[0].cdat[4] = 0;
 656   1              OneTime[0].cdat[5] = 0xFF;              
 657   1              OneTime[0].cdat[6] = 0xFF;
 658   1              OneTime[0].cdat[7] = 0xFF;
 659   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 660   1              OneTime[1].cdat[1] = 0;
 661   1              OneTime[1].cdat[2] = 0;
 662   1              OneTime[1].cdat[3] = 0;
 663   1              OneTime[1].cdat[4] = 0x80;
 664   1              OneTime[1].cdat[5] = 0;
 665   1              OneTime[1].cdat[6] = 0;
 666   1              OneTime[1].cdat[7] = 0;
 667   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 668   1              SimpleButtonConfig(,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 669   1      */
 670   1      
 671   1      
 672   1      
 673   1      /*************************************************************************
 674   1              RxMessage filters / traps
 675   1              Below example:
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 12  

 676   1              First half, Watches for ID 0x6E8 on can port 1 (C).  Only byte 3 matters 
 677   1              as the mask is set to 0's for all else.  The matching value required in  
 678   1              byte 3 is 0x58. 8 bytes expected.
 679   1              Second half, configures output message 0x6E3 on port 1 (C). 8 bytes in 
 680   1              count.  mask is ANDed with cyclic message and ORed with value, but in 
 681   1              this example there is no cyclic message, therefor mask is ignored and 
 682   1              value is just output as the data 1 time. Take care to use the index value
 683   1              returned from the first function as input parameter to 2nd function
 684   1      **************************************************************************/
 685   1              OneTime[0].cdat[0] = 0;         // mask bits (0's don't cares, 1's are matches)
 686   1              OneTime[0].cdat[1] = 0;
 687   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
 688   1              OneTime[0].cdat[3] = 0xFF;      // this byte matters
 689   1              OneTime[0].cdat[4] = 0;
 690   1              OneTime[0].cdat[5] = 0;  
 691   1              OneTime[0].cdat[6] = 0;
 692   1              OneTime[0].cdat[7] = 0;
 693   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 694   1              OneTime[1].cdat[1] = 0;
 695   1              OneTime[1].cdat[2] = 0;
 696   1              OneTime[1].cdat[3] = 0x58;      // selector switches to x58 causes triggers
 697   1              OneTime[1].cdat[4] = 0;
 698   1              OneTime[1].cdat[5] = 0;
 699   1              OneTime[1].cdat[6] = 0;
 700   1              OneTime[1].cdat[7] = 0;
 701   1      // configure Rx filter, look for this message match
 702   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
 703   1              index = RxMessageConfig1(1,0x6E8,OneTime[0].cdat,OneTime[1].cdat,8);
 704   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 705   1              OneTime[0].cdat[1] = 0xFF;
 706   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 707   1              OneTime[0].cdat[3] = 0xFF;
 708   1              OneTime[0].cdat[4] = 0xFF;
 709   1              OneTime[0].cdat[5] = 0xFF;
 710   1              OneTime[0].cdat[6] = 0xFF;
 711   1              OneTime[0].cdat[7] = 0xFF;
 712   1              OneTime[1].cdat[0] = 0x88;      // values (ORed)
 713   1              OneTime[1].cdat[1] = 0x99;
 714   1              OneTime[1].cdat[2] = 0xAA;
 715   1              OneTime[1].cdat[3] = 0xBB;
 716   1              OneTime[1].cdat[4] = 0xCC;
 717   1              OneTime[1].cdat[5] = 0xDD;
 718   1              OneTime[1].cdat[6] = 0xEE;
 719   1              OneTime[1].cdat[7] = 0xFF;
 720   1      // configure Tx output caused by above Recieved message
 721   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
 722   1              RxMessageConfig2(index,1,0x6E3,OneTime[0].cdat,OneTime[1].cdat,8,1);
 723   1      
 724   1      
 725   1      // Detect and set for English
 726   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 727   1              OneTime[0].cdat[1] = 0xFF;
 728   1              OneTime[0].cdat[2] = 0xFF;      
 729   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 730   1              OneTime[1].cdat[1] = 3;
 731   1              OneTime[1].cdat[2] = 1;         // this byte must match
 732   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 733   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 734   1              OneTime[0].cdat[1] = 0xFF;
 735   1              OneTime[0].cdat[2] = 0xFF;      
 736   1              OneTime[0].cdat[3] = 0xFF;
 737   1              OneTime[0].cdat[4] = 0xFF;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 13  

 738   1              OneTime[0].cdat[5] = 0xFF;
 739   1              OneTime[0].cdat[6] = 0x0;       // clear
 740   1              OneTime[0].cdat[7] = 0xFF;
 741   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 742   1              OneTime[1].cdat[1] = 0;
 743   1              OneTime[1].cdat[2] = 0;
 744   1              OneTime[1].cdat[3] = 0;
 745   1              OneTime[1].cdat[4] = 0;
 746   1              OneTime[1].cdat[5] = 0;
 747   1              OneTime[1].cdat[6] = 8;         // write
 748   1              OneTime[1].cdat[7] = 0;         // note altercount = 0 means permanant
 749   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 750   1      
 751   1      // Detect and set for spa
 752   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 753   1              OneTime[0].cdat[1] = 0xFF;
 754   1              OneTime[0].cdat[2] = 0xFF;      
 755   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 756   1              OneTime[1].cdat[1] = 3;
 757   1              OneTime[1].cdat[2] = 4;         // this byte must match
 758   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 759   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 760   1              OneTime[0].cdat[1] = 0xFF;
 761   1              OneTime[0].cdat[2] = 0xFF;      
 762   1              OneTime[0].cdat[3] = 0xFF;
 763   1              OneTime[0].cdat[4] = 0xFF;
 764   1              OneTime[0].cdat[5] = 0xFF;
 765   1              OneTime[0].cdat[6] = 0x0;       // clear
 766   1              OneTime[0].cdat[7] = 0xFF;
 767   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 768   1              OneTime[1].cdat[1] = 0;
 769   1              OneTime[1].cdat[2] = 0;
 770   1              OneTime[1].cdat[3] = 0;
 771   1              OneTime[1].cdat[4] = 0;
 772   1              OneTime[1].cdat[5] = 0;
 773   1              OneTime[1].cdat[6] = 0x20;      // write
 774   1              OneTime[1].cdat[7] = 0;
 775   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 776   1      
 777   1      // Detect and set for ger
 778   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 779   1              OneTime[0].cdat[1] = 0xFF;
 780   1              OneTime[0].cdat[2] = 0xFF;      
 781   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 782   1              OneTime[1].cdat[1] = 3;
 783   1              OneTime[1].cdat[2] = 0;         // this byte must match
 784   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 785   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 786   1              OneTime[0].cdat[1] = 0xFF;
 787   1              OneTime[0].cdat[2] = 0xFF;      
 788   1              OneTime[0].cdat[3] = 0xFF;
 789   1              OneTime[0].cdat[4] = 0xFF;
 790   1              OneTime[0].cdat[5] = 0xFF;
 791   1              OneTime[0].cdat[6] = 0x0;       // clear
 792   1              OneTime[0].cdat[7] = 0xFF;
 793   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 794   1              OneTime[1].cdat[1] = 0;
 795   1              OneTime[1].cdat[2] = 0;
 796   1              OneTime[1].cdat[3] = 0;
 797   1              OneTime[1].cdat[4] = 0;
 798   1              OneTime[1].cdat[5] = 0;
 799   1              OneTime[1].cdat[6] = 0;         // write
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 14  

 800   1              OneTime[1].cdat[7] = 0;
 801   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 802   1      
 803   1      // Detect and set for fre
 804   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 805   1              OneTime[0].cdat[1] = 0xFF;
 806   1              OneTime[0].cdat[2] = 0xFF;      
 807   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 808   1              OneTime[1].cdat[1] = 3;
 809   1              OneTime[1].cdat[2] = 2;         // this byte must match
 810   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 811   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 812   1              OneTime[0].cdat[1] = 0xFF;
 813   1              OneTime[0].cdat[2] = 0xFF;      
 814   1              OneTime[0].cdat[3] = 0xFF;
 815   1              OneTime[0].cdat[4] = 0xFF;
 816   1              OneTime[0].cdat[5] = 0xFF;
 817   1              OneTime[0].cdat[6] = 0x0;       // clear
 818   1              OneTime[0].cdat[7] = 0xFF;
 819   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 820   1              OneTime[1].cdat[1] = 0;
 821   1              OneTime[1].cdat[2] = 0;
 822   1              OneTime[1].cdat[3] = 0;
 823   1              OneTime[1].cdat[4] = 0;
 824   1              OneTime[1].cdat[5] = 0;
 825   1              OneTime[1].cdat[6] = 0x10;      // write
 826   1              OneTime[1].cdat[7] = 0;
 827   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 828   1      
 829   1      // Detect and set for ita
 830   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 831   1              OneTime[0].cdat[1] = 0xFF;
 832   1              OneTime[0].cdat[2] = 0xFF;      
 833   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 834   1              OneTime[1].cdat[1] = 3;
 835   1              OneTime[1].cdat[2] = 3;         // this byte must match
 836   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 837   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 838   1              OneTime[0].cdat[1] = 0xFF;
 839   1              OneTime[0].cdat[2] = 0xFF;      
 840   1              OneTime[0].cdat[3] = 0xFF;
 841   1              OneTime[0].cdat[4] = 0xFF;
 842   1              OneTime[0].cdat[5] = 0xFF;
 843   1              OneTime[0].cdat[6] = 0x0;       // clear
 844   1              OneTime[0].cdat[7] = 0xFF;
 845   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 846   1              OneTime[1].cdat[1] = 0;
 847   1              OneTime[1].cdat[2] = 0;
 848   1              OneTime[1].cdat[3] = 0;
 849   1              OneTime[1].cdat[4] = 0;
 850   1              OneTime[1].cdat[5] = 0;
 851   1              OneTime[1].cdat[6] = 0x60;      // write
 852   1              OneTime[1].cdat[7] = 0;
 853   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 854   1      
 855   1      // Detect and set for jap
 856   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 857   1              OneTime[0].cdat[1] = 0xFF;
 858   1              OneTime[0].cdat[2] = 0xFF;      
 859   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 860   1              OneTime[1].cdat[1] = 3;
 861   1              OneTime[1].cdat[2] = 5;         // this byte must match
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 15  

 862   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 863   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 864   1              OneTime[0].cdat[1] = 0xFF;
 865   1              OneTime[0].cdat[2] = 0xFF;      
 866   1              OneTime[0].cdat[3] = 0xFF;
 867   1              OneTime[0].cdat[4] = 0xFF;
 868   1              OneTime[0].cdat[5] = 0xFF;
 869   1              OneTime[0].cdat[6] = 0x0;       // clear
 870   1              OneTime[0].cdat[7] = 0xFF;
 871   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 872   1              OneTime[1].cdat[1] = 0;
 873   1              OneTime[1].cdat[2] = 0;
 874   1              OneTime[1].cdat[3] = 0;
 875   1              OneTime[1].cdat[4] = 0;
 876   1              OneTime[1].cdat[5] = 0;
 877   1              OneTime[1].cdat[6] = 0x50;      // write
 878   1              OneTime[1].cdat[7] = 0;
 879   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 880   1      
 881   1      // Detect and set for chs
 882   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 883   1              OneTime[0].cdat[1] = 0xFF;
 884   1              OneTime[0].cdat[2] = 0xFF;      
 885   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 886   1              OneTime[1].cdat[1] = 3;
 887   1              OneTime[1].cdat[2] = 9;         // this byte must match
 888   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 889   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 890   1              OneTime[0].cdat[1] = 0xFF;
 891   1              OneTime[0].cdat[2] = 0xFF;      
 892   1              OneTime[0].cdat[3] = 0xFF;
 893   1              OneTime[0].cdat[4] = 0xFF;
 894   1              OneTime[0].cdat[5] = 0xFF;
 895   1              OneTime[0].cdat[6] = 0x0;       // clear
 896   1              OneTime[0].cdat[7] = 0xFF;
 897   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 898   1              OneTime[1].cdat[1] = 0;
 899   1              OneTime[1].cdat[2] = 0;
 900   1              OneTime[1].cdat[3] = 0;
 901   1              OneTime[1].cdat[4] = 0;
 902   1              OneTime[1].cdat[5] = 0;
 903   1              OneTime[1].cdat[6] = 0x48;      // write
 904   1              OneTime[1].cdat[7] = 0;
 905   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 906   1      
 907   1      // Detect and set for cht
 908   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 909   1              OneTime[0].cdat[1] = 0xFF;
 910   1              OneTime[0].cdat[2] = 0xFF;      
 911   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 912   1              OneTime[1].cdat[1] = 3;
 913   1              OneTime[1].cdat[2] = 0xE;       // this byte must match
 914   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 915   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 916   1              OneTime[0].cdat[1] = 0xFF;
 917   1              OneTime[0].cdat[2] = 0xFF;      
 918   1              OneTime[0].cdat[3] = 0xFF;
 919   1              OneTime[0].cdat[4] = 0xFF;
 920   1              OneTime[0].cdat[5] = 0xFF;
 921   1              OneTime[0].cdat[6] = 0x0;       // clear
 922   1              OneTime[0].cdat[7] = 0xFF;
 923   1              OneTime[1].cdat[0] = 0;         // values (ORed)
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 16  

 924   1              OneTime[1].cdat[1] = 0;
 925   1              OneTime[1].cdat[2] = 0;
 926   1              OneTime[1].cdat[3] = 0;
 927   1              OneTime[1].cdat[4] = 0;
 928   1              OneTime[1].cdat[5] = 0;
 929   1              OneTime[1].cdat[6] = 0x90;      // write
 930   1              OneTime[1].cdat[7] = 0;
 931   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 932   1      
 933   1              // Configure Relay's
 934   1              RelayCnf[3] = REL_IGN | 1 | REL_NOT;    // relay 4 comes on with Ignition switch setting not 1
 935   1              //RelayCnf[2] = REL_BUTT | 1 | REL_TOG; // relay 3 toggles with button 1
 936   1              //RelayCnf[1] = REL_RX | 0 | REL_PULSE; // relay 2 with first (0) rxtrap configured
 937   1              //RelayCnf[0] = REL_TX | 3 | REL_PULSE; // relay 1 with 4th (3) TxMesg configured
 938   1      
 939   1      /*************************************************************************
 940   1              User running loop 
 941   1      **************************************************************************/
 942   1              cnt = 0;
 943   1              counter =0;
 944   1              while(!(keyChange & 0xF)) 
 945   1              {
 946   2                      if (RxCAN0)             // new message to process
 947   2                      {
 948   3                              for (index = 1 ; index < RX0BUFFERS && rxframe0[index].MsgNum>=RX0BUFFERS ; index++);
 949   3      
 950   3                              if (index < RX0BUFFERS)
 951   3                              {
 952   4                                      ProcessRx(0,index);
 953   4                                      rxframe0[index].MsgNum = 0;
 954   4                              }
 955   3                              RxCAN0 = 0;
 956   3                      }
 957   2                      if (RxCAN1)             // new message to process
 958   2                      {
 959   3                              error = CAN1readStatus();
 960   3      
 961   3                              index = RX1BUFFERS;
 962   3                              index1 = RX1BUFFERS;
 963   3                              if (error & MCP_RX1IF)
 964   3                                      index1 = CAN1read_canMsg( MCP_READ_RX1 );        
 965   3                              if (error & MCP_RX0IF)
 966   3                                      index = CAN1read_canMsg( MCP_READ_RX0 );        
 967   3                              if (error = CAN1readRegister(MCP_EFLG))
 968   3                              {
 969   4                                      ErrCnt++;
 970   4                                      AlterMessageByte(1,0x6E2,7,1,ErrCnt,0);
 971   4      
 972   4                                      if (error & MCP_EFLG_RX1OVR)
 973   4                                              CAN1modifyRegister(MCP_EFLG,MCP_EFLG_RX1OVR,0);
 974   4                                      if (error & MCP_EFLG_RX0OVR)
 975   4                                              CAN1modifyRegister(MCP_EFLG,MCP_EFLG_RX0OVR,0);
 976   4                              }
 977   3      
 978   3                              // clear int flags
 979   3                              IE0 = 0;                                        // clear IE0 flag re-enabling interupt
 980   3                              RxCAN1 = 0;                                     // clear my flag interupt occured
 981   3                              EX0 = 1;                                        // enable CAN1 interupt
 982   3      
 983   3                              if (index < RX1BUFFERS)                         // process recieved message from Rx0
 984   3                              {
 985   4                                      ProcessRx(1,index);             // CAN1 messages
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 17  

 986   4                              }
 987   3                              if (index1 < RX1BUFFERS)                        // process recieved message from Rx1
 988   3                              {
 989   4                                      ProcessRx(1,index1);
 990   4                              }
 991   3                      }
 992   2      
 993   2                      if (StartTicks + ONESEC < msticks )     // every second
 994   2                      {
 995   3                              StartTicks = msticks;
 996   3                              LED1 ^= 1;
 997   3      
 998   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
 999   3                              if (index1 < TXBUFFS)                           // empty one time available
1000   3                              {
1001   4                                      OneTime[index1].cdat[0] = (U8)(keys>>24);
1002   4                                      OneTime[index1].cdat[1] = (U8)(keys>>16);
1003   4                                      OneTime[index1].cdat[2] = (U8)(keys>>8);
1004   4                                      OneTime[index1].cdat[3] = (U8)keys;
1005   4                                      OneTime[index1].cdat[4] = CAN1readStatus();
1006   4                                      OneTime[index1].cdat[5] = CAN1readRxStat();
1007   4                                      OneTime[index1].cdat[6] = CAN1readRegister(MCP_CANSTAT);
1008   4                                      OneTime[index1].cdat[7] = CAN1readRegister(MCP_CANINTF);
1009   4                                      AlterMessageByte(0,0x6EA,0,OneTime[index1].cdat,8,1);
1010   4                              }
1011   3      
1012   3                              // VIN
1013   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
1014   3                              if (index1 < TXBUFFS)                           // empty one time available
1015   3                              {
1016   4                                      switch (vin++)
1017   4                                      {
1018   5                                              case 0:
1019   5                                                      OneTime[index1].cdat[0] = 0;
1020   5                                                      for (index = 0 ; index < 7 ; index++)
1021   5                                                              OneTime[index1].cdat[1+index] = VIN[index];
1022   5                                                      break;
1023   5                                              case 1:
1024   5                                                      OneTime[index1].cdat[0] = 1;
1025   5                                                      for (index = 7 ; index < 14 ; index++)
1026   5                                                              OneTime[index1].cdat[index-6] = VIN[index];
1027   5                                                      break;
1028   5                                              case 2:
1029   5                                                      OneTime[index1].cdat[0] = 2;
1030   5                                                      for (index = 14 ; index < 17 ; index++)
1031   5                                                              OneTime[index1].cdat[index-13] = VIN[index];
1032   5                                                      vin = 0;
1033   5                                                      break;
1034   5                                      }
1035   4                                      AlterMessageByte(0,0x3D3,0,OneTime[index1].cdat,8,0);
1036   4                              }
1037   3      
1038   3                              if (counter++ >= 9)     // test every 10 seconds alter 6E2 message
1039   3                              {
1040   4                                      for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
1041   4                                      if (index1 < TXBUFFS)                           // empty one time available
1042   4                                      {
1043   5                                              OneTime[index1].cdat[0] = cnt++;
1044   5                                              AlterMessageByte(1,0x6E2,6,OneTime[index1].cdat,1,2);
1045   5                                              counter = 0;
1046   5                                      }
1047   4                              }
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 18  

1048   3                      }
1049   2      
1050   2      
1051   2                      if (RelayChange)
1052   2                              CheckRelay();
1053   2      
1054   2                      // check for buttons pressed and process
1055   2                      if (keyChange & 0xFFFFF00)      // At least one Buttons changed state
1056   2                      {
1057   3                              CheckButts();                   // SimpleButton Check
1058   3      
1059   3                              keyChange &= (U32)((BUTTONMASK<<8) & 0xFF);     // clear unused buttons
1060   3                      }
1061   2      
1062   2      
1063   2                      if (keyChange & 0xF0)           // Ignition change
1064   2                      {
1065   3                              // check if a relay is set to Ignition change
1066   3                              for (index1 = 0 ; index1 < 4; index1++){
1067   4                                      if ((RelayCnf[index1] & 0xF00) == REL_IGN)      // Relay controled by IGN select
1068   4                                      {
1069   5                                              if ((RelayCnf[index1]&0xFF) == ((keys>>4)&0xF)) // matching Select
1070   5                                                      RelayChange |= 1<<index1;                       // flag for relay "on" change
1071   5                                              else
1072   5                                                      RelayChange |= 0x10<<index1;            // flag for relay "off" change
1073   5                                      }
1074   4                              }
1075   3      
1076   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
1077   3                              if (index1 < TXBUFFS)                           // empty one time available
1078   3                              {
1079   4                                      IGN_OFF = 0;                    // default IGN_OFF flag to off
1080   4                                      switch(keys & 0xF0)
1081   4                                      {
1082   5                                              case 0x10:      // IGN_OFF
1083   5                                                      // ID 190, alter byte 0,1 
1084   5                                                      OneTime[index1].cdat[0] = 0x00;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1085   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1086   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1087   5      
1088   5                                                      // ID 98, alter bytes 2,3  
1089   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1090   5                                                      OneTime[index1].cdat[1] = 0x0;
1091   5                                                      OneTime[index1].cdat[2] = 0x0;
1092   5                                                      OneTime[index1].cdat[3] = 0x0;
1093   5                                                      AlterMessageByte(0,0x098,0,OneTime[index1].cdat,4,0);
1094   5                                                      IGN_OFF = 1;    // TURN on IGN_OFF flag
1095   5                                                      IGN_OFF_FLG= 0;
1096   5                                                      break;
1097   5                                              case 0x20:      // IGN_ACC
1098   5                                                      // ID 190, alter byte 0,1 
1099   5                                                      OneTime[index1].cdat[0] = 0x03;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1100   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1101   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1102   5      
1103   5                                                      // ID 98, alter bytes 2,3  
1104   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1105   5                                                      OneTime[index1].cdat[1] = 0x0;
1106   5                                                      OneTime[index1].cdat[2] = 0x0;
1107   5                                                      OneTime[index1].cdat[3] = 0x0;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 19  

1108   5                                                      AlterMessageByte(0,0x098,0,OneTime[index1].cdat,4,0);
1109   5                                                      IGN_OFF_FLG = 1;
1110   5                                                      break;
1111   5                                              case 0x30:      // IGN_START
1112   5                                                      // ID 190, alter byte 0,1 
1113   5                                                      OneTime[index1].cdat[0] = 0x05;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1114   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1115   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1116   5      
1117   5                                                      // ID 98, alter bytes 2,3  
1118   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1119   5                                                      OneTime[index1].cdat[1] = 0x0;
1120   5                                                      OneTime[index1].cdat[2] = 0x0;
1121   5                                                      OneTime[index1].cdat[3] = 0x0;
1122   5                                                      AlterMessageByte(0,0x098,2,OneTime[index1].cdat,4,0);
1123   5                                                      IGN_OFF_FLG = 1;
1124   5                                                      break;
1125   5                                              case 0x40:      // IGN_RUN_0
1126   5                                                      // ID 190, alter byte 0,1 
1127   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1128   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1129   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1130   5      
1131   5                                                      // ID 98, alter bytes 2,3  
1132   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1133   5                                                      OneTime[index1].cdat[1] = 0x0;
1134   5                                                      OneTime[index1].cdat[2] = 0x0;
1135   5                                                      OneTime[index1].cdat[3] = 0x0;
1136   5                                                      AlterMessageByte(0,0x098,0,OneTime[index1].cdat,4,0);
1137   5                                                      IGN_OFF_FLG = 1;
1138   5                                                      break;
1139   5                                              case 0x50:      // IGN_RUN_5
1140   5                                              // ID 190, alter byte 0,1 
1141   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1142   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1143   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1144   5      
1145   5                                                      // ID 98, alter bytes 2,3  
1146   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1147   5                                                      OneTime[index1].cdat[1] = 0x0;
1148   5                                                      OneTime[index1].cdat[2] = 0x0;
1149   5                                                      OneTime[index1].cdat[3] = 0x80;
1150   5                                                      AlterMessageByte(0,0x098,0,OneTime[index1].cdat,4,0);
1151   5                                                      IGN_OFF_FLG = 1;
1152   5                                                      break;
1153   5                                              case 0x60:      // IGN_RUN_10
1154   5                                              // ID 190, alter byte 0,1 
1155   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1156   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1157   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1158   5      
1159   5                                                      // ID 98, alter bytes 2,3  
1160   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1161   5                                                      OneTime[index1].cdat[1] = 0x0;
1162   5                                                      OneTime[index1].cdat[2] = 0x0;
1163   5                                                      OneTime[index1].cdat[3] = 0xFD;
1164   5                                                      AlterMessageByte(0,0x098,0,OneTime[index1].cdat,4,0);
1165   5                                                      IGN_OFF_FLG = 1;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 20  

1166   5                                                      break;
1167   5                                              
1168   5                                              case 0x70:
1169   5                                                      break;
1170   5                                              case 0x80:
1171   5                                                      break;
1172   5                                      }
1173   4      
1174   4                              keyChange &= ~0xF0;             // clear Ignition nibble
1175   4                              }
1176   3                      }
1177   2              }
1178   1      }
1179          void User2()    // program select 2, PNET
1180          {       
1181   1              U32 StartTicks = 0;
1182   1              U8  index,index1,ErrCnt,counter,vin,error, cnt;
1183   1              bit IGN_OFF=1;
1184   1      
1185   1              char VIN[17] = "1C3CCCCB7FN1124UC";
1186   1      
1187   1              error = 0;      ErrCnt=0;
1188   1      
1189   1      
1190   1      
1191   1      /***************************************************************************************
1192   1      ****************************************************************************************
1193   1              CAUTION WATCH XDATA BOUNDARIES.  NOT AUTOMATIC ITS UP TO YOU!!!!!!
1194   1      ****************************************************************************************
1195   1              // CODE CURRENTLY USES 809 xdata bytes.  THEREFORE STARTING CAN BE AT 0x32A
1196   1              // watch at compile the xdata bytes used. if xdata > 810d need to change below
1197   1              // xdata space ends at 0xFFF.
1198   1      ***************************************************************************************/
1199   1      //      Buttons = (BUTTABLE xdata *)0x32A;      // 20 buttons takes 32Abytes => 0x32A-0x4E1
1200   1              ButtCnt = 0;                                            // each Button = 20 bytes
1201   1      
1202   1      //      Mesgs = (MSGTABLE xdata *)0x4E2;        // 0x4E2-0x93F -> space for 43 Tx messages 
1203   1              MesgCnt = 0;                                            // each Mesgs = 26 bytes
1204   1      
1205   1      //      RxMesg = (RxMESG xdata *)0x940;         // 0x940-0xFF8 -> space for 43 Rx messages 
1206   1              RxCnt = 0;                                                      // each RxMesg = 40 bytes
1207   1      
1208   1      // AUTOMATED above some,
1209   1      // Make Sure XDATASPACE define follows compile output value  
1210   1      #define XDATASPACE 810          // starting free address
1211   1      
1212   1      /***************************************************************************************
1213   1      // Currently (809 xdata start) you get 43 Tx messages and 43 Rx message traps.  If you 
1214   1      // need more of one and less of the other you can manipulate the starting numbers below
1215   1      // to get it to work.
1216   1      // also note RX0 buff size is 32 messages on CAN0, and RX1 buff size is 16 for CAN1
1217   1      ***************************************************************************************/
1218   1              MaxMesgs = 45;                  // number of Tx message configs
1219   1              MaxRxTraps = 45;                // number of Rx message configs
1220   1              while(!MemManage(MAXBUTTONS,MaxMesgs,MaxRxTraps,XDATASPACE))    // 20 button configs  
1221   1              {
1222   2                      MaxRxTraps--;           // reduce Message buffers till it fits.
1223   2                      if (!MemManage(MAXBUTTONS,MaxMesgs,MaxRxTraps,XDATASPACE))
1224   2                              MaxMesgs--;             // reduce Message buffers till it fits
1225   2              }
1226   1      /**************************************************************************************/
1227   1      
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 21  

1228   1      
1229   1      /*************************************************************************
1230   1              Repeating message setups
1231   1              example below-
1232   1              message ID 0x6E2 is created at rate of 500mSec on port 1 (C). With 8 bytes 
1233   1              of data, shown are it's defaults.
1234   1      **************************************************************************/
1235   1                      
1236   1              OneTime[0].cdat[0] = 0;
1237   1              OneTime[0].cdat[1] = 0; 
1238   1              OneTime[0].cdat[2] = 0;
1239   1              OneTime[0].cdat[3] = 0;
1240   1              AddMessage(0,0x122,500,4,OneTime[0].cdat);  // CBC_I4 - IGN state
1241   1              
1242   1              OneTime[0].cdat[0] = 0;
1243   1              OneTime[0].cdat[1] = 0; 
1244   1              OneTime[0].cdat[2] = 0;
1245   1              OneTime[0].cdat[3] = 0;
1246   1              OneTime[0].cdat[4] = 0;
1247   1              OneTime[0].cdat[5] = 0;
1248   1              OneTime[0].cdat[6] = 0;
1249   1              OneTime[0].cdat[7] = 0;
1250   1              AddMessage(0,0x22D,200,8,OneTime[0].cdat);  // SWS_8 - Steering Wheel messages
1251   1              
1252   1              OneTime[0].cdat[0] = 0;
1253   1              OneTime[0].cdat[1] = 0; 
1254   1              OneTime[0].cdat[2] = 0;
1255   1              OneTime[0].cdat[3] = 0;
1256   1              OneTime[0].cdat[4] = 0;
1257   1              OneTime[0].cdat[5] = 0;
1258   1              OneTime[0].cdat[6] = 0;
1259   1              OneTime[0].cdat[7] = 0;
1260   1              AddMessage(0,0x273,1000,8,OneTime[0].cdat);  // ICS_KNOBS
1261   1              
1262   1              OneTime[0].cdat[0] = 0;
1263   1              OneTime[0].cdat[1] = 0; 
1264   1              OneTime[0].cdat[2] = 0x07;
1265   1              OneTime[0].cdat[3] = 0;
1266   1              OneTime[0].cdat[4] = 0;
1267   1              OneTime[0].cdat[5] = 0;
1268   1              OneTime[0].cdat[6] = 0;
1269   1              OneTime[0].cdat[7] = 0;
1270   1              AddMessage(0,0x2AD,1000,8,OneTime[0].cdat);  // CBC_CFG2
1271   1              
1272   1              OneTime[0].cdat[0] = 0x18;
1273   1              OneTime[0].cdat[1] = 0x38;      
1274   1              OneTime[0].cdat[2] = 0x8B;
1275   1              OneTime[0].cdat[3] = 0;
1276   1              AddMessage(0,0x2C2,200,4,OneTime[0].cdat);  // CBC_I3
1277   1              
1278   1              OneTime[0].cdat[0] = 0;
1279   1              OneTime[0].cdat[1] = 0xEE;      
1280   1              OneTime[0].cdat[2] = 0xEE;
1281   1              OneTime[0].cdat[3] = 0x2E;
1282   1              OneTime[0].cdat[4] = 0;
1283   1              OneTime[0].cdat[5] = 0;
1284   1              OneTime[0].cdat[6] = 0;
1285   1              OneTime[0].cdat[7] = 0;
1286   1              AddMessage(0,0x2C5,2000,8,OneTime[0].cdat);  // EcuCfg16
1287   1              
1288   1              OneTime[0].cdat[0] = 0;
1289   1              OneTime[0].cdat[1] = 0; 
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 22  

1290   1              OneTime[0].cdat[2] = 0;
1291   1              OneTime[0].cdat[3] = 0;
1292   1              OneTime[0].cdat[4] = 0;
1293   1              OneTime[0].cdat[5] = 0;
1294   1              OneTime[0].cdat[6] = 0;
1295   1              OneTime[0].cdat[7] = 0;
1296   1              AddMessage(0,0x2D3,1000,8,OneTime[0].cdat);  // ICS_MSG
1297   1              
1298   1              OneTime[0].cdat[0] = 0;
1299   1              OneTime[0].cdat[1] = 0x01;      
1300   1              OneTime[0].cdat[2] = 0xC8;
1301   1              OneTime[0].cdat[3] = 0x18;
1302   1              OneTime[0].cdat[4] = 0;
1303   1              OneTime[0].cdat[5] = 0;
1304   1              OneTime[0].cdat[6] = 0;
1305   1              OneTime[0].cdat[7] = 0x01;
1306   1              AddMessage(0,0x2FA,500,8,OneTime[0].cdat);  // CBC_I2
1307   1              
1308   1              OneTime[0].cdat[0] = 0;
1309   1              OneTime[0].cdat[1] = 0; 
1310   1              OneTime[0].cdat[2] = 0;
1311   1              OneTime[0].cdat[3] = 0;
1312   1              OneTime[0].cdat[4] = 0;
1313   1              OneTime[0].cdat[5] = 0x83;
1314   1              OneTime[0].cdat[6] = 0;
1315   1              OneTime[0].cdat[7] = 0;
1316   1              AddMessage(0,0x305,1000,8,OneTime[0].cdat);  // CBC_I6
1317   1              
1318   1              OneTime[0].cdat[0] = 0x19;
1319   1              OneTime[0].cdat[1] = 0; 
1320   1              OneTime[0].cdat[2] = 0;
1321   1              OneTime[0].cdat[3] = 0x01;
1322   1              OneTime[0].cdat[4] = 0;
1323   1              OneTime[0].cdat[5] = 0;
1324   1              OneTime[0].cdat[6] = 0;
1325   1              OneTime[0].cdat[7] = 0;
1326   1              AddMessage(0,0x381,2000,8,OneTime[0].cdat);  // VehCfg7
1327   1              
1328   1              OneTime[0].cdat[0] = 0;
1329   1              OneTime[0].cdat[1] = 0x01;      
1330   1              OneTime[0].cdat[2] = 0x4C;
1331   1              OneTime[0].cdat[3] = 0;
1332   1              OneTime[0].cdat[4] = 0;
1333   1              OneTime[0].cdat[5] = 0;
1334   1              AddMessage(0,0x3A2,1000,6,OneTime[0].cdat);  // CBC_I5
1335   1              
1336   1              OneTime[0].cdat[0] = 0x01;
1337   1              OneTime[0].cdat[1] = 0; 
1338   1              OneTime[0].cdat[2] = 0x80;
1339   1              OneTime[0].cdat[3] = 0;
1340   1              OneTime[0].cdat[4] = 0;
1341   1              OneTime[0].cdat[5] = 0xFF;
1342   1              OneTime[0].cdat[6] = 0xFF;
1343   1              OneTime[0].cdat[7] = 0;
1344   1              AddMessage(0,0x3B2,500,8,OneTime[0].cdat);  // CBC_I1
1345   1              
1346   1              OneTime[0].cdat[0] = 0x45;
1347   1              OneTime[0].cdat[1] = 0x30;      
1348   1              OneTime[0].cdat[2] = 0x22;
1349   1              OneTime[0].cdat[3] = 0x01;
1350   1              OneTime[0].cdat[4] = 0x61;
1351   1              OneTime[0].cdat[5] = 0xA7;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 23  

1352   1              OneTime[0].cdat[6] = 0xC7;
1353   1              OneTime[0].cdat[7] = 0x98;
1354   1              AddMessage(0,0x3B3,2000,8,OneTime[0].cdat);  // VehCfgCSM1
1355   1              
1356   1              OneTime[0].cdat[0] = 0xFD;
1357   1              OneTime[0].cdat[1] = 0x80;      
1358   1              OneTime[0].cdat[2] = 0;
1359   1              OneTime[0].cdat[3] = 0;
1360   1              OneTime[0].cdat[4] = 0;
1361   1              OneTime[0].cdat[5] = 0;
1362   1              OneTime[0].cdat[6] = 0;
1363   1              OneTime[0].cdat[7] = 0;
1364   1              AddMessage(0,0x3B4,2000,8,OneTime[0].cdat);  // VehCfgCSM2
1365   1              
1366   1              OneTime[0].cdat[0] = 0x3E;
1367   1              OneTime[0].cdat[1] = 0x1E;      
1368   1              OneTime[0].cdat[2] = 0x1E;
1369   1              OneTime[0].cdat[3] = 0;
1370   1              OneTime[0].cdat[4] = 0x03;
1371   1              OneTime[0].cdat[5] = 0x01;
1372   1              OneTime[0].cdat[6] = 0x91;
1373   1              OneTime[0].cdat[7] = 0x01;
1374   1              AddMessage(0,0x3DE,500,8,OneTime[0].cdat);  // CBC_CFG1
1375   1              
1376   1              OneTime[0].cdat[0] = 0;
1377   1              OneTime[0].cdat[1] = 0; 
1378   1              OneTime[0].cdat[2] = 0;
1379   1              OneTime[0].cdat[3] = 0;
1380   1              OneTime[0].cdat[4] = 0;
1381   1              OneTime[0].cdat[5] = 0;
1382   1              OneTime[0].cdat[6] = 0;
1383   1              OneTime[0].cdat[7] = 0;
1384   1              AddMessage(0,0x3E0,1000,8,OneTime[0].cdat);  // VIN
1385   1              
1386   1              OneTime[0].cdat[0] = 0xFD;
1387   1              OneTime[0].cdat[1] = 0x0C;      
1388   1              OneTime[0].cdat[2] = 0x10;
1389   1              OneTime[0].cdat[3] = 0x08;
1390   1              OneTime[0].cdat[4] = 0;
1391   1              OneTime[0].cdat[5] = 0;
1392   1              OneTime[0].cdat[6] = 0;
1393   1              OneTime[0].cdat[7] = 0;
1394   1              AddMessage(0,0x3E3,2000,8,OneTime[0].cdat);  // NET_CFG_INT
1395   1              
1396   1              OneTime[0].cdat[0] = 0x89;
1397   1              OneTime[0].cdat[1] = 0xDA;      
1398   1              OneTime[0].cdat[2] = 0x98;
1399   1              OneTime[0].cdat[3] = 0x06;
1400   1              OneTime[0].cdat[4] = 0;
1401   1              OneTime[0].cdat[5] = 0;
1402   1              OneTime[0].cdat[6] = 0;
1403   1              OneTime[0].cdat[7] = 0;
1404   1              AddMessage(0,0x3E4,2000,8,OneTime[0].cdat);  //NET_CFG_PT
1405   1              
1406   1              OneTime[0].cdat[0] = 0x41;
1407   1              OneTime[0].cdat[1] = 0x29;      
1408   1              OneTime[0].cdat[2] = 0xA2;
1409   1              OneTime[0].cdat[3] = 0x15;
1410   1              OneTime[0].cdat[4] = 0x1E;
1411   1              OneTime[0].cdat[5] = 0x80;
1412   1              OneTime[0].cdat[6] = 0xA2;
1413   1              OneTime[0].cdat[7] = 0x10;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 24  

1414   1              AddMessage(0,0x3E8,2000,8,OneTime[0].cdat);  // VehCfg1
1415   1              
1416   1              OneTime[0].cdat[0] = 0x01;
1417   1              OneTime[0].cdat[1] = 0; 
1418   1              OneTime[0].cdat[2] = 0x06;
1419   1              OneTime[0].cdat[3] = 0x9E;
1420   1              OneTime[0].cdat[4] = 0x20;
1421   1              OneTime[0].cdat[5] = 0x20;
1422   1              OneTime[0].cdat[6] = 0x20;
1423   1              OneTime[0].cdat[7] = 0x20;
1424   1              AddMessage(0,0x3E9,2000,8,OneTime[0].cdat);  // VehCfg2
1425   1              
1426   1              OneTime[0].cdat[0] = 0x41;
1427   1              OneTime[0].cdat[1] = 0x0D;      
1428   1              OneTime[0].cdat[2] = 0x22;
1429   1              OneTime[0].cdat[3] = 0x48;
1430   1              OneTime[0].cdat[4] = 0x80;
1431   1              OneTime[0].cdat[5] = 0x24;
1432   1              OneTime[0].cdat[6] = 0x03;
1433   1              OneTime[0].cdat[7] = 0x40;
1434   1              AddMessage(0,0x3EA,2000,8,OneTime[0].cdat);  // VehCfg3
1435   1              
1436   1              OneTime[0].cdat[0] = 0x40;
1437   1              OneTime[0].cdat[1] = 0; 
1438   1              OneTime[0].cdat[2] = 0;
1439   1              OneTime[0].cdat[3] = 0;
1440   1              OneTime[0].cdat[4] = 0;
1441   1              OneTime[0].cdat[5] = 0;
1442   1              OneTime[0].cdat[6] = 0x08;
1443   1              OneTime[0].cdat[7] = 0xC6;
1444   1              AddMessage(0,0x3EB,2000,8,OneTime[0].cdat);  // VehCfg4
1445   1              
1446   1              OneTime[0].cdat[0] = 0x45;
1447   1              OneTime[0].cdat[1] = 0x02;      
1448   1              OneTime[0].cdat[2] = 0x1D;
1449   1              OneTime[0].cdat[3] = 0x20;
1450   1              OneTime[0].cdat[4] = 0x1D;
1451   1              OneTime[0].cdat[5] = 0xA0;
1452   1              OneTime[0].cdat[6] = 0;
1453   1              OneTime[0].cdat[7] = 0x03;
1454   1              AddMessage(0,0x3F2,2000,8,OneTime[0].cdat);  // EcuCfg3
1455   1              
1456   1              OneTime[0].cdat[0] = 0x01;
1457   1              OneTime[0].cdat[1] = 0; 
1458   1              OneTime[0].cdat[2] = 0;
1459   1              OneTime[0].cdat[3] = 0;
1460   1              OneTime[0].cdat[4] = 0;
1461   1              OneTime[0].cdat[5] = 0;
1462   1              OneTime[0].cdat[6] = 0;
1463   1              OneTime[0].cdat[7] = 0x20;
1464   1              AddMessage(0,0x44A,2000,8,OneTime[0].cdat);  // VehCfg5
1465   1              
1466   1              OneTime[0].cdat[0] = 0x01;
1467   1              OneTime[0].cdat[1] = 0; 
1468   1              OneTime[0].cdat[2] = 0;
1469   1              OneTime[0].cdat[3] = 0;
1470   1              OneTime[0].cdat[4] = 0;
1471   1              OneTime[0].cdat[5] = 0;
1472   1              OneTime[0].cdat[6] = 0;
1473   1              OneTime[0].cdat[7] = 0;
1474   1              AddMessage(0,0x44C,2000,8,OneTime[0].cdat);  // VehCfg6
1475   1              
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 25  

1476   1              OneTime[0].cdat[0] = 0;
1477   1              OneTime[0].cdat[1] = 0; 
1478   1              OneTime[0].cdat[2] = 0;
1479   1              OneTime[0].cdat[3] = 0;
1480   1              OneTime[0].cdat[4] = 0;
1481   1              OneTime[0].cdat[5] = 0;
1482   1              OneTime[0].cdat[6] = 0;
1483   1              OneTime[0].cdat[7] = 0;
1484   1              AddMessage(0,0x322,100,8,OneTime[0].cdat);  // GW_C1
1485   1      
1486   1      
1487   1      /*************************************************************************
1488   1              Button setup
1489   1              example below -
1490   1              pressing button 1 causes byte 5 of message 0x6E2 to be altered to 0xAA 
1491   1              for the next 5 outputs. The mask clears byte 5 leaving the rest alone.  
1492   1              The value (0xAA) is ORed into byte 5.
1493   1      **************************************************************************/
1494   1              #define BUTTONMASK 0xF  // only button 1 defined (bit 1) 
1495   1      
1496   1              // Volume Up
1497   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1498   1              OneTime[0].cdat[1] = 0xFF;
1499   1              OneTime[0].cdat[2] = 0; // using OneTime structure as temp storage
1500   1              OneTime[0].cdat[3] = 0xFF;
1501   1              OneTime[0].cdat[4] = 0xFF;
1502   1              OneTime[0].cdat[5] = 0xFF;              
1503   1              OneTime[0].cdat[6] = 0xFF;
1504   1              OneTime[0].cdat[7] = 0xFF;
1505   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1506   1              OneTime[1].cdat[1] = 0;
1507   1              OneTime[1].cdat[2] = 0x01;
1508   1              OneTime[1].cdat[3] = 0;
1509   1              OneTime[1].cdat[4] = 0;
1510   1              OneTime[1].cdat[5] = 0;
1511   1              OneTime[1].cdat[6] = 0;
1512   1              OneTime[1].cdat[7] = 0;
1513   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1514   1              SimpleButtonConfig(19,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1515   1      
1516   1              // Volume Down
1517   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1518   1              OneTime[0].cdat[1] = 0xFF;
1519   1              OneTime[0].cdat[2] = 0; // using OneTime structure as temp storage
1520   1              OneTime[0].cdat[3] = 0xFF;
1521   1              OneTime[0].cdat[4] = 0xFF;
1522   1              OneTime[0].cdat[5] = 0xFF;              
1523   1              OneTime[0].cdat[6] = 0xFF;
1524   1              OneTime[0].cdat[7] = 0xFF;
1525   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1526   1              OneTime[1].cdat[1] = 0;
1527   1              OneTime[1].cdat[2] = 0x04;
1528   1              OneTime[1].cdat[3] = 0;
1529   1              OneTime[1].cdat[4] = 0;
1530   1              OneTime[1].cdat[5] = 0;
1531   1              OneTime[1].cdat[6] = 0;
1532   1              OneTime[1].cdat[7] = 0;
1533   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1534   1              SimpleButtonConfig(9,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1535   1      
1536   1              // Mode
1537   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 26  

1538   1              OneTime[0].cdat[1] = 0xFF;
1539   1              OneTime[0].cdat[2] = 0; // using OneTime structure as temp storage
1540   1              OneTime[0].cdat[3] = 0xFF;
1541   1              OneTime[0].cdat[4] = 0xFF;
1542   1              OneTime[0].cdat[5] = 0xFF;              
1543   1              OneTime[0].cdat[6] = 0xFF;
1544   1              OneTime[0].cdat[7] = 0xFF;
1545   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1546   1              OneTime[1].cdat[1] = 0;
1547   1              OneTime[1].cdat[2] = 0x10;
1548   1              OneTime[1].cdat[3] = 0;
1549   1              OneTime[1].cdat[4] = 0;
1550   1              OneTime[1].cdat[5] = 0;
1551   1              OneTime[1].cdat[6] = 0;
1552   1              OneTime[1].cdat[7] = 0;
1553   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1554   1              SimpleButtonConfig(18,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1555   1      
1556   1              // Preset
1557   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1558   1              OneTime[0].cdat[1] = 0xFF;
1559   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1560   1              OneTime[0].cdat[3] = 0xFF;
1561   1              OneTime[0].cdat[4] = 0;
1562   1              OneTime[0].cdat[5] = 0xFF;              
1563   1              OneTime[0].cdat[6] = 0xFF;
1564   1              OneTime[0].cdat[7] = 0xFF;
1565   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1566   1              OneTime[1].cdat[1] = 0;
1567   1              OneTime[1].cdat[2] = 0;
1568   1              OneTime[1].cdat[3] = 0;
1569   1              OneTime[1].cdat[4] = 0x01;
1570   1              OneTime[1].cdat[5] = 0;
1571   1              OneTime[1].cdat[6] = 0;
1572   1              OneTime[1].cdat[7] = 0;
1573   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1574   1              SimpleButtonConfig(8,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1575   1      
1576   1              // Seek Up
1577   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1578   1              OneTime[0].cdat[1] = 0xFF;
1579   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
1580   1              OneTime[0].cdat[3] = 0xFF;
1581   1              OneTime[0].cdat[4] = 0xFF;
1582   1              OneTime[0].cdat[5] = 0xFF;              
1583   1              OneTime[0].cdat[6] = 0xFF;
1584   1              OneTime[0].cdat[7] = 0xFF;
1585   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1586   1              OneTime[1].cdat[1] = 0;
1587   1              OneTime[1].cdat[2] = 0x40;
1588   1              OneTime[1].cdat[3] = 0;
1589   1              OneTime[1].cdat[4] = 0;
1590   1              OneTime[1].cdat[5] = 0;
1591   1              OneTime[1].cdat[6] = 0;
1592   1              OneTime[1].cdat[7] = 0;
1593   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1594   1              SimpleButtonConfig(17,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1595   1      
1596   1              // Seek Down
1597   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1598   1              OneTime[0].cdat[1] = 0xFF;
1599   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 27  

1600   1              OneTime[0].cdat[3] = 0;
1601   1              OneTime[0].cdat[4] = 0xFF;
1602   1              OneTime[0].cdat[5] = 0xFF;              
1603   1              OneTime[0].cdat[6] = 0xFF;
1604   1              OneTime[0].cdat[7] = 0xFF;
1605   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1606   1              OneTime[1].cdat[1] = 0;
1607   1              OneTime[1].cdat[2] = 0;
1608   1              OneTime[1].cdat[3] = 0x01;
1609   1              OneTime[1].cdat[4] = 0;
1610   1              OneTime[1].cdat[5] = 0;
1611   1              OneTime[1].cdat[6] = 0;
1612   1              OneTime[1].cdat[7] = 0;
1613   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1614   1              SimpleButtonConfig(7,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1615   1      
1616   1              // Phone Pickup
1617   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1618   1              OneTime[0].cdat[1] = 0xFF;
1619   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1620   1              OneTime[0].cdat[3] = 0;
1621   1              OneTime[0].cdat[4] = 0xFF;
1622   1              OneTime[0].cdat[5] = 0xFF;              
1623   1              OneTime[0].cdat[6] = 0xFF;
1624   1              OneTime[0].cdat[7] = 0xFF;
1625   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1626   1              OneTime[1].cdat[1] = 0;
1627   1              OneTime[1].cdat[2] = 0;
1628   1              OneTime[1].cdat[3] = 0x10;
1629   1              OneTime[1].cdat[4] = 0;
1630   1              OneTime[1].cdat[5] = 0;
1631   1              OneTime[1].cdat[6] = 0;
1632   1              OneTime[1].cdat[7] = 0;
1633   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1634   1              SimpleButtonConfig(16,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1635   1      
1636   1              // Phone Hangup
1637   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1638   1              OneTime[0].cdat[1] = 0xFF;
1639   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1640   1              OneTime[0].cdat[3] = 0;
1641   1              OneTime[0].cdat[4] = 0xFF;
1642   1              OneTime[0].cdat[5] = 0xFF;              
1643   1              OneTime[0].cdat[6] = 0xFF;
1644   1              OneTime[0].cdat[7] = 0xFF;
1645   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1646   1              OneTime[1].cdat[1] = 0;
1647   1              OneTime[1].cdat[2] = 0;
1648   1              OneTime[1].cdat[3] = 0x40;
1649   1              OneTime[1].cdat[4] = 0;
1650   1              OneTime[1].cdat[5] = 0;
1651   1              OneTime[1].cdat[6] = 0;
1652   1              OneTime[1].cdat[7] = 0;
1653   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1654   1              SimpleButtonConfig(6,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1655   1      
1656   1              // VR
1657   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1658   1              OneTime[0].cdat[1] = 0xFF;
1659   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1660   1              OneTime[0].cdat[3] = 0xFF;
1661   1              OneTime[0].cdat[4] = 0;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 28  

1662   1              OneTime[0].cdat[5] = 0xFF;              
1663   1              OneTime[0].cdat[6] = 0xFF;
1664   1              OneTime[0].cdat[7] = 0xFF;
1665   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1666   1              OneTime[1].cdat[1] = 0;
1667   1              OneTime[1].cdat[2] = 0;
1668   1              OneTime[1].cdat[3] = 0;
1669   1              OneTime[1].cdat[4] = 0x04;
1670   1              OneTime[1].cdat[5] = 0;
1671   1              OneTime[1].cdat[6] = 0;
1672   1              OneTime[1].cdat[7] = 0;
1673   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1674   1              SimpleButtonConfig(15,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1675   1      
1676   1              // Screen Off
1677   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1678   1              OneTime[0].cdat[1] = 0xFF;
1679   1              OneTime[0].cdat[2] = 0; // using OneTime structure as temp storage
1680   1              OneTime[0].cdat[3] = 0xFF;
1681   1              OneTime[0].cdat[4] = 0xFF;
1682   1              OneTime[0].cdat[5] = 0xFF;              
1683   1              OneTime[0].cdat[6] = 0xFF;
1684   1              OneTime[0].cdat[7] = 0xFF;
1685   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1686   1              OneTime[1].cdat[1] = 0;
1687   1              OneTime[1].cdat[2] = 0x20;
1688   1              OneTime[1].cdat[3] = 0;
1689   1              OneTime[1].cdat[4] = 0;
1690   1              OneTime[1].cdat[5] = 0;
1691   1              OneTime[1].cdat[6] = 0;
1692   1              OneTime[1].cdat[7] = 0;
1693   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1694   1              SimpleButtonConfig(5,0,0x2D3,OneTime[0].cdat,OneTime[1].cdat,1);
1695   1      
1696   1              // Mute
1697   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1698   1              OneTime[0].cdat[1] = 0xFF;
1699   1              OneTime[0].cdat[2] = 0; // using OneTime structure as temp storage
1700   1              OneTime[0].cdat[3] = 0xFF;
1701   1              OneTime[0].cdat[4] = 0xFF;
1702   1              OneTime[0].cdat[5] = 0xFF;              
1703   1              OneTime[0].cdat[6] = 0xFF;
1704   1              OneTime[0].cdat[7] = 0xFF;
1705   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1706   1              OneTime[1].cdat[1] = 0;
1707   1              OneTime[1].cdat[2] = 0x01;
1708   1              OneTime[1].cdat[3] = 0;
1709   1              OneTime[1].cdat[4] = 0;
1710   1              OneTime[1].cdat[5] = 0;
1711   1              OneTime[1].cdat[6] = 0;
1712   1              OneTime[1].cdat[7] = 0;
1713   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1714   1              SimpleButtonConfig(14,0,0x2D3,OneTime[0].cdat,OneTime[1].cdat,1);
1715   1      
1716   1              // Back
1717   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1718   1              OneTime[0].cdat[1] = 0xFF;
1719   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1720   1              OneTime[0].cdat[3] = 0;
1721   1              OneTime[0].cdat[4] = 0xFF;
1722   1              OneTime[0].cdat[5] = 0xFF;              
1723   1              OneTime[0].cdat[6] = 0xFF;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 29  

1724   1              OneTime[0].cdat[7] = 0xFF;
1725   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1726   1              OneTime[1].cdat[1] = 0;
1727   1              OneTime[1].cdat[2] = 0;
1728   1              OneTime[1].cdat[3] = 0x02;
1729   1              OneTime[1].cdat[4] = 0;
1730   1              OneTime[1].cdat[5] = 0;
1731   1              OneTime[1].cdat[6] = 0;
1732   1              OneTime[1].cdat[7] = 0;
1733   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1734   1              SimpleButtonConfig(4,0,0x2D3,OneTime[0].cdat,OneTime[1].cdat,1);
1735   1      
1736   1              // Browse/Enter
1737   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1738   1              OneTime[0].cdat[1] = 0xFF;
1739   1              OneTime[0].cdat[2] = 0; // using OneTime structure as temp storage
1740   1              OneTime[0].cdat[3] = 0xFF;
1741   1              OneTime[0].cdat[4] = 0xFF;
1742   1              OneTime[0].cdat[5] = 0xFF;              
1743   1              OneTime[0].cdat[6] = 0xFF;
1744   1              OneTime[0].cdat[7] = 0xFF;
1745   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1746   1              OneTime[1].cdat[1] = 0;
1747   1              OneTime[1].cdat[2] = 0x02;
1748   1              OneTime[1].cdat[3] = 0;
1749   1              OneTime[1].cdat[4] = 0;
1750   1              OneTime[1].cdat[5] = 0;
1751   1              OneTime[1].cdat[6] = 0;
1752   1              OneTime[1].cdat[7] = 0;
1753   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1754   1              SimpleButtonConfig(13,0,0x2D3,OneTime[0].cdat,OneTime[1].cdat,1);
1755   1      
1756   1              // Screenshot
1757   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1758   1              OneTime[0].cdat[1] = 0xFF;
1759   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1760   1              OneTime[0].cdat[3] = 0xFF;
1761   1              OneTime[0].cdat[4] = 0xFF;
1762   1              OneTime[0].cdat[5] = 0;         
1763   1              OneTime[0].cdat[6] = 0xFF;
1764   1              OneTime[0].cdat[7] = 0xFF;
1765   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1766   1              OneTime[1].cdat[1] = 0;
1767   1              OneTime[1].cdat[2] = 0;
1768   1              OneTime[1].cdat[3] = 0;
1769   1              OneTime[1].cdat[4] = 0;
1770   1              OneTime[1].cdat[5] = 0x4C;
1771   1              OneTime[1].cdat[6] = 0;
1772   1              OneTime[1].cdat[7] = 0;
1773   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1774   1              SimpleButtonConfig(3,0,0x2D3,OneTime[0].cdat,OneTime[1].cdat,5);
1775   1      
1776   1      
1777   1              // ENG. Mode
1778   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1779   1              OneTime[0].cdat[1] = 0xFF;
1780   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1781   1              OneTime[0].cdat[3] = 0xFF;
1782   1              OneTime[0].cdat[4] = 0xFF;
1783   1              OneTime[0].cdat[5] = 0;         
1784   1              OneTime[0].cdat[6] = 0xFF;
1785   1              OneTime[0].cdat[7] = 0xFF;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 30  

1786   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1787   1              OneTime[1].cdat[1] = 0;
1788   1              OneTime[1].cdat[2] = 0;
1789   1              OneTime[1].cdat[3] = 0;
1790   1              OneTime[1].cdat[4] = 0;
1791   1              OneTime[1].cdat[5] = 0x0C;
1792   1              OneTime[1].cdat[6] = 0;
1793   1              OneTime[1].cdat[7] = 0;
1794   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1795   1              SimpleButtonConfig(12,0,0x2D3,OneTime[0].cdat,OneTime[1].cdat,5);
1796   1      
1797   1              // Dealer Mode
1798   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1799   1              OneTime[0].cdat[1] = 0xFF;
1800   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1801   1              OneTime[0].cdat[3] = 0xFF;
1802   1              OneTime[0].cdat[4] = 0xFF;
1803   1              OneTime[0].cdat[5] = 0;         
1804   1              OneTime[0].cdat[6] = 0xFF;
1805   1              OneTime[0].cdat[7] = 0xFF;
1806   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1807   1              OneTime[1].cdat[1] = 0;
1808   1              OneTime[1].cdat[2] = 0;
1809   1              OneTime[1].cdat[3] = 0;
1810   1              OneTime[1].cdat[4] = 0;
1811   1              OneTime[1].cdat[5] = 0x8C;
1812   1              OneTime[1].cdat[6] = 0;
1813   1              OneTime[1].cdat[7] = 0;
1814   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1815   1              SimpleButtonConfig(2,0,0x2D3,OneTime[0].cdat,OneTime[1].cdat,5);
1816   1      
1817   1      
1818   1              // Night Mode
1819   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1820   1              OneTime[0].cdat[1] = 0;
1821   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1822   1              OneTime[0].cdat[3] = 0xFF;
1823   1              OneTime[0].cdat[4] = 0xFF;
1824   1              OneTime[0].cdat[5] = 0xFF;              
1825   1              OneTime[0].cdat[6] = 0xFF;
1826   1              OneTime[0].cdat[7] = 0xFF;
1827   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1828   1              OneTime[1].cdat[1] = 0x00;
1829   1              OneTime[1].cdat[2] = 0;
1830   1              OneTime[1].cdat[3] = 0;
1831   1              OneTime[1].cdat[4] = 0;
1832   1              OneTime[1].cdat[5] = 0;
1833   1              OneTime[1].cdat[6] = 0;
1834   1              OneTime[1].cdat[7] = 0;
1835   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1836   1              SimpleButtonConfig(11,0,0x2FA,OneTime[0].cdat,OneTime[1].cdat,1); 
1837   1      
1838   1              // Day Mode
1839   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1840   1              OneTime[0].cdat[1] = 0;
1841   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1842   1              OneTime[0].cdat[3] = 0xFF;
1843   1              OneTime[0].cdat[4] = 0xFF;
1844   1              OneTime[0].cdat[5] = 0xFF;              
1845   1              OneTime[0].cdat[6] = 0xFF;
1846   1              OneTime[0].cdat[7] = 0xFF;
1847   1              OneTime[1].cdat[0] = 0;         // values (ORed)
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 31  

1848   1              OneTime[1].cdat[1] = 0x01;
1849   1              OneTime[1].cdat[2] = 0;
1850   1              OneTime[1].cdat[3] = 0;
1851   1              OneTime[1].cdat[4] = 0;
1852   1              OneTime[1].cdat[5] = 0;
1853   1              OneTime[1].cdat[6] = 0;
1854   1              OneTime[1].cdat[7] = 0;
1855   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1856   1              SimpleButtonConfig(1,0,0x2FA,OneTime[0].cdat,OneTime[1].cdat,1);
1857   1      /*
1858   1              // Door Ajar
1859   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1860   1              OneTime[0].cdat[1] = 0xFF;
1861   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1862   1              OneTime[0].cdat[3] = 0xFF;
1863   1              OneTime[0].cdat[4] = 0;
1864   1              OneTime[0].cdat[5] = 0xFF;              
1865   1              OneTime[0].cdat[6] = 0xFF;
1866   1              OneTime[0].cdat[7] = 0xFF;
1867   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1868   1              OneTime[1].cdat[1] = 0;
1869   1              OneTime[1].cdat[2] = 0;
1870   1              OneTime[1].cdat[3] = 0;
1871   1              OneTime[1].cdat[4] = 0x80;
1872   1              OneTime[1].cdat[5] = 0;
1873   1              OneTime[1].cdat[6] = 0;
1874   1              OneTime[1].cdat[7] = 0;
1875   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1876   1              SimpleButtonConfig(10,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1877   1      
1878   1              // Theft Alarm
1879   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1880   1              OneTime[0].cdat[1] = 0xFF;
1881   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1882   1              OneTime[0].cdat[3] = 0xFF;
1883   1              OneTime[0].cdat[4] = 0;
1884   1              OneTime[0].cdat[5] = 0xFF;              
1885   1              OneTime[0].cdat[6] = 0xFF;
1886   1              OneTime[0].cdat[7] = 0xFF;
1887   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1888   1              OneTime[1].cdat[1] = 0;
1889   1              OneTime[1].cdat[2] = 0;
1890   1              OneTime[1].cdat[3] = 0;
1891   1              OneTime[1].cdat[4] = 0x80;
1892   1              OneTime[1].cdat[5] = 0;
1893   1              OneTime[1].cdat[6] = 0;
1894   1              OneTime[1].cdat[7] = 0;
1895   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1896   1              SimpleButtonConfig(,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,1);
1897   1      */
1898   1      
1899   1      // Phone Pickup Long Press
1900   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1901   1              OneTime[0].cdat[1] = 0xFF;
1902   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1903   1              OneTime[0].cdat[3] = 0;
1904   1              OneTime[0].cdat[4] = 0xFF;
1905   1              OneTime[0].cdat[5] = 0xFF;              
1906   1              OneTime[0].cdat[6] = 0xFF;
1907   1              OneTime[0].cdat[7] = 0xFF;
1908   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1909   1              OneTime[1].cdat[1] = 0;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 32  

1910   1              OneTime[1].cdat[2] = 0;
1911   1              OneTime[1].cdat[3] = 0x10;
1912   1              OneTime[1].cdat[4] = 0;
1913   1              OneTime[1].cdat[5] = 0;
1914   1              OneTime[1].cdat[6] = 0;
1915   1              OneTime[1].cdat[7] = 0;
1916   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1917   1              SimpleButtonConfig(10,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,3);
1918   1      
1919   1      // VR Long Press
1920   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1921   1              OneTime[0].cdat[1] = 0xFF;
1922   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1923   1              OneTime[0].cdat[3] = 0xFF;
1924   1              OneTime[0].cdat[4] = 0;
1925   1              OneTime[0].cdat[5] = 0xFF;              
1926   1              OneTime[0].cdat[6] = 0xFF;
1927   1              OneTime[0].cdat[7] = 0xFF;
1928   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1929   1              OneTime[1].cdat[1] = 0;
1930   1              OneTime[1].cdat[2] = 0;
1931   1              OneTime[1].cdat[3] = 0;
1932   1              OneTime[1].cdat[4] = 0x04;
1933   1              OneTime[1].cdat[5] = 0;
1934   1              OneTime[1].cdat[6] = 0;
1935   1              OneTime[1].cdat[7] = 0;
1936   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1937   1              SimpleButtonConfig(0,0,0x22D,OneTime[0].cdat,OneTime[1].cdat,3);
1938   1      
1939   1      
1940   1      
1941   1      /*************************************************************************
1942   1              RxMessage filters / traps
1943   1              Below example:
1944   1              First half, Watches for ID 0x6E8 on can port 1 (C).  Only byte 3 matters 
1945   1              as the mask is set to 0's for all else.  The matching value required in  
1946   1              byte 3 is 0x58. 8 bytes expected.
1947   1              Second half, configures output message 0x6E3 on port 1 (C). 8 bytes in 
1948   1              count.  mask is ANDed with cyclic message and ORed with value, but in 
1949   1              this example there is no cyclic message, therefor mask is ignored and 
1950   1              value is just output as the data 1 time. Take care to use the index value
1951   1              returned from the first function as input parameter to 2nd function
1952   1      **************************************************************************/
1953   1              OneTime[0].cdat[0] = 0;         // mask bits (0's don't cares, 1's are matches)
1954   1              OneTime[0].cdat[1] = 0;
1955   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
1956   1              OneTime[0].cdat[3] = 0xFF;      // this byte matters
1957   1              OneTime[0].cdat[4] = 0;
1958   1              OneTime[0].cdat[5] = 0;  
1959   1              OneTime[0].cdat[6] = 0;
1960   1              OneTime[0].cdat[7] = 0;
1961   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1962   1              OneTime[1].cdat[1] = 0;
1963   1              OneTime[1].cdat[2] = 0;
1964   1              OneTime[1].cdat[3] = 0x58;      // selector switches to x58 causes triggers
1965   1              OneTime[1].cdat[4] = 0;
1966   1              OneTime[1].cdat[5] = 0;
1967   1              OneTime[1].cdat[6] = 0;
1968   1              OneTime[1].cdat[7] = 0;
1969   1      // configure Rx filter, look for this message match
1970   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
1971   1              index = RxMessageConfig1(1,0x6E8,OneTime[0].cdat,OneTime[1].cdat,8);
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 33  

1972   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1973   1              OneTime[0].cdat[1] = 0xFF;
1974   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1975   1              OneTime[0].cdat[3] = 0xFF;
1976   1              OneTime[0].cdat[4] = 0xFF;
1977   1              OneTime[0].cdat[5] = 0xFF;
1978   1              OneTime[0].cdat[6] = 0xFF;
1979   1              OneTime[0].cdat[7] = 0xFF;
1980   1              OneTime[1].cdat[0] = 0x88;      // values (ORed)
1981   1              OneTime[1].cdat[1] = 0x99;
1982   1              OneTime[1].cdat[2] = 0xAA;
1983   1              OneTime[1].cdat[3] = 0xBB;
1984   1              OneTime[1].cdat[4] = 0xCC;
1985   1              OneTime[1].cdat[5] = 0xDD;
1986   1              OneTime[1].cdat[6] = 0xEE;
1987   1              OneTime[1].cdat[7] = 0xFF;
1988   1      // configure Tx output caused by above Recieved message
1989   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
1990   1              RxMessageConfig2(index,1,0x6E3,OneTime[0].cdat,OneTime[1].cdat,8,1);
1991   1      
1992   1      
1993   1      // Detect and set for English
1994   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
1995   1              OneTime[0].cdat[1] = 0xFF;
1996   1              OneTime[0].cdat[2] = 0xFF;      
1997   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
1998   1              OneTime[1].cdat[1] = 3;
1999   1              OneTime[1].cdat[2] = 1;         // this byte must match
2000   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2001   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2002   1              OneTime[0].cdat[1] = 0xFF;
2003   1              OneTime[0].cdat[2] = 0xFF;      
2004   1              OneTime[0].cdat[3] = 0xFF;
2005   1              OneTime[0].cdat[4] = 0xFF;
2006   1              OneTime[0].cdat[5] = 0xFF;
2007   1              OneTime[0].cdat[6] = 0x0;       // clear
2008   1              OneTime[0].cdat[7] = 0xFF;
2009   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2010   1              OneTime[1].cdat[1] = 0;
2011   1              OneTime[1].cdat[2] = 0;
2012   1              OneTime[1].cdat[3] = 0;
2013   1              OneTime[1].cdat[4] = 0;
2014   1              OneTime[1].cdat[5] = 0;
2015   1              OneTime[1].cdat[6] = 8;         // write
2016   1              OneTime[1].cdat[7] = 0;         // note altercount = 0 means permanant
2017   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2018   1      
2019   1      // Detect and set for spa
2020   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2021   1              OneTime[0].cdat[1] = 0xFF;
2022   1              OneTime[0].cdat[2] = 0xFF;      
2023   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2024   1              OneTime[1].cdat[1] = 3;
2025   1              OneTime[1].cdat[2] = 4;         // this byte must match
2026   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2027   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2028   1              OneTime[0].cdat[1] = 0xFF;
2029   1              OneTime[0].cdat[2] = 0xFF;      
2030   1              OneTime[0].cdat[3] = 0xFF;
2031   1              OneTime[0].cdat[4] = 0xFF;
2032   1              OneTime[0].cdat[5] = 0xFF;
2033   1              OneTime[0].cdat[6] = 0x0;       // clear
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 34  

2034   1              OneTime[0].cdat[7] = 0xFF;
2035   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2036   1              OneTime[1].cdat[1] = 0;
2037   1              OneTime[1].cdat[2] = 0;
2038   1              OneTime[1].cdat[3] = 0;
2039   1              OneTime[1].cdat[4] = 0;
2040   1              OneTime[1].cdat[5] = 0;
2041   1              OneTime[1].cdat[6] = 0x20;      // write
2042   1              OneTime[1].cdat[7] = 0;
2043   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2044   1      
2045   1      // Detect and set for ger
2046   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2047   1              OneTime[0].cdat[1] = 0xFF;
2048   1              OneTime[0].cdat[2] = 0xFF;      
2049   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2050   1              OneTime[1].cdat[1] = 3;
2051   1              OneTime[1].cdat[2] = 0;         // this byte must match
2052   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2053   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2054   1              OneTime[0].cdat[1] = 0xFF;
2055   1              OneTime[0].cdat[2] = 0xFF;      
2056   1              OneTime[0].cdat[3] = 0xFF;
2057   1              OneTime[0].cdat[4] = 0xFF;
2058   1              OneTime[0].cdat[5] = 0xFF;
2059   1              OneTime[0].cdat[6] = 0x0;       // clear
2060   1              OneTime[0].cdat[7] = 0xFF;
2061   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2062   1              OneTime[1].cdat[1] = 0;
2063   1              OneTime[1].cdat[2] = 0;
2064   1              OneTime[1].cdat[3] = 0;
2065   1              OneTime[1].cdat[4] = 0;
2066   1              OneTime[1].cdat[5] = 0;
2067   1              OneTime[1].cdat[6] = 0;         // write
2068   1              OneTime[1].cdat[7] = 0;
2069   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2070   1      
2071   1      // Detect and set for fre
2072   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2073   1              OneTime[0].cdat[1] = 0xFF;
2074   1              OneTime[0].cdat[2] = 0xFF;      
2075   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2076   1              OneTime[1].cdat[1] = 3;
2077   1              OneTime[1].cdat[2] = 2;         // this byte must match
2078   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2079   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2080   1              OneTime[0].cdat[1] = 0xFF;
2081   1              OneTime[0].cdat[2] = 0xFF;      
2082   1              OneTime[0].cdat[3] = 0xFF;
2083   1              OneTime[0].cdat[4] = 0xFF;
2084   1              OneTime[0].cdat[5] = 0xFF;
2085   1              OneTime[0].cdat[6] = 0x0;       // clear
2086   1              OneTime[0].cdat[7] = 0xFF;
2087   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2088   1              OneTime[1].cdat[1] = 0;
2089   1              OneTime[1].cdat[2] = 0;
2090   1              OneTime[1].cdat[3] = 0;
2091   1              OneTime[1].cdat[4] = 0;
2092   1              OneTime[1].cdat[5] = 0;
2093   1              OneTime[1].cdat[6] = 0x10;      // write
2094   1              OneTime[1].cdat[7] = 0;
2095   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 35  

2096   1      
2097   1      // Detect and set for ita
2098   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2099   1              OneTime[0].cdat[1] = 0xFF;
2100   1              OneTime[0].cdat[2] = 0xFF;      
2101   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2102   1              OneTime[1].cdat[1] = 3;
2103   1              OneTime[1].cdat[2] = 3;         // this byte must match
2104   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2105   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2106   1              OneTime[0].cdat[1] = 0xFF;
2107   1              OneTime[0].cdat[2] = 0xFF;      
2108   1              OneTime[0].cdat[3] = 0xFF;
2109   1              OneTime[0].cdat[4] = 0xFF;
2110   1              OneTime[0].cdat[5] = 0xFF;
2111   1              OneTime[0].cdat[6] = 0x0;       // clear
2112   1              OneTime[0].cdat[7] = 0xFF;
2113   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2114   1              OneTime[1].cdat[1] = 0;
2115   1              OneTime[1].cdat[2] = 0;
2116   1              OneTime[1].cdat[3] = 0;
2117   1              OneTime[1].cdat[4] = 0;
2118   1              OneTime[1].cdat[5] = 0;
2119   1              OneTime[1].cdat[6] = 0x60;      // write
2120   1              OneTime[1].cdat[7] = 0;
2121   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2122   1      
2123   1      // Detect and set for jap
2124   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2125   1              OneTime[0].cdat[1] = 0xFF;
2126   1              OneTime[0].cdat[2] = 0xFF;      
2127   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2128   1              OneTime[1].cdat[1] = 3;
2129   1              OneTime[1].cdat[2] = 5;         // this byte must match
2130   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2131   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2132   1              OneTime[0].cdat[1] = 0xFF;
2133   1              OneTime[0].cdat[2] = 0xFF;      
2134   1              OneTime[0].cdat[3] = 0xFF;
2135   1              OneTime[0].cdat[4] = 0xFF;
2136   1              OneTime[0].cdat[5] = 0xFF;
2137   1              OneTime[0].cdat[6] = 0x0;       // clear
2138   1              OneTime[0].cdat[7] = 0xFF;
2139   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2140   1              OneTime[1].cdat[1] = 0;
2141   1              OneTime[1].cdat[2] = 0;
2142   1              OneTime[1].cdat[3] = 0;
2143   1              OneTime[1].cdat[4] = 0;
2144   1              OneTime[1].cdat[5] = 0;
2145   1              OneTime[1].cdat[6] = 0x50;      // write
2146   1              OneTime[1].cdat[7] = 0;
2147   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2148   1      
2149   1      // Detect and set for chs
2150   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2151   1              OneTime[0].cdat[1] = 0xFF;
2152   1              OneTime[0].cdat[2] = 0xFF;      
2153   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2154   1              OneTime[1].cdat[1] = 3;
2155   1              OneTime[1].cdat[2] = 9;         // this byte must match
2156   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2157   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 36  

2158   1              OneTime[0].cdat[1] = 0xFF;
2159   1              OneTime[0].cdat[2] = 0xFF;      
2160   1              OneTime[0].cdat[3] = 0xFF;
2161   1              OneTime[0].cdat[4] = 0xFF;
2162   1              OneTime[0].cdat[5] = 0xFF;
2163   1              OneTime[0].cdat[6] = 0x0;       // clear
2164   1              OneTime[0].cdat[7] = 0xFF;
2165   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2166   1              OneTime[1].cdat[1] = 0;
2167   1              OneTime[1].cdat[2] = 0;
2168   1              OneTime[1].cdat[3] = 0;
2169   1              OneTime[1].cdat[4] = 0;
2170   1              OneTime[1].cdat[5] = 0;
2171   1              OneTime[1].cdat[6] = 0x48;      // write
2172   1              OneTime[1].cdat[7] = 0;
2173   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2174   1      
2175   1      // Detect and set for cht
2176   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2177   1              OneTime[0].cdat[1] = 0xFF;
2178   1              OneTime[0].cdat[2] = 0xFF;      
2179   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2180   1              OneTime[1].cdat[1] = 3;
2181   1              OneTime[1].cdat[2] = 0xE;       // this byte must match
2182   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2183   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2184   1              OneTime[0].cdat[1] = 0xFF;
2185   1              OneTime[0].cdat[2] = 0xFF;      
2186   1              OneTime[0].cdat[3] = 0xFF;
2187   1              OneTime[0].cdat[4] = 0xFF;
2188   1              OneTime[0].cdat[5] = 0xFF;
2189   1              OneTime[0].cdat[6] = 0x0;       // clear
2190   1              OneTime[0].cdat[7] = 0xFF;
2191   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2192   1              OneTime[1].cdat[1] = 0;
2193   1              OneTime[1].cdat[2] = 0;
2194   1              OneTime[1].cdat[3] = 0;
2195   1              OneTime[1].cdat[4] = 0;
2196   1              OneTime[1].cdat[5] = 0;
2197   1              OneTime[1].cdat[6] = 0x90;      // write
2198   1              OneTime[1].cdat[7] = 0;
2199   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2200   1      
2201   1              // Configure Relay's
2202   1              RelayCnf[3] = REL_IGN | 1 | REL_NOT;    // relay 4 comes on with Ignition switch setting not 1
2203   1              //RelayCnf[2] = REL_BUTT | 1 | REL_TOG; // relay 3 toggles with button 1
2204   1              //RelayCnf[1] = REL_RX | 0 | REL_PULSE; // relay 2 with first (0) rxtrap configured
2205   1              //RelayCnf[0] = REL_TX | 3 | REL_PULSE; // relay 1 with 4th (3) TxMesg configured
2206   1      
2207   1      /*************************************************************************
2208   1              User running loop 
2209   1      **************************************************************************/
2210   1              cnt = 0;
2211   1              counter =0;
2212   1              
2213   1              while(!(keyChange & 0xF))
2214   1              {
2215   2                      
2216   2                      if (RxCAN0)             // new message to process
2217   2                      {
2218   3                              for (index = 1 ; index < RX0BUFFERS && rxframe0[index].MsgNum>=RX0BUFFERS ; index++);
2219   3      
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 37  

2220   3                              if (index < RX0BUFFERS)
2221   3                              {
2222   4                                      ProcessRx(0,index);
2223   4                                      rxframe0[index].MsgNum = 0;
2224   4                              }
2225   3                              RxCAN0 = 0;
2226   3                      }
2227   2                      if (RxCAN1)             // new message to process
2228   2                      {
2229   3                              error = CAN1readStatus();
2230   3      
2231   3                              index = RX1BUFFERS;
2232   3                              index1 = RX1BUFFERS;
2233   3                              if (error & MCP_RX1IF)
2234   3                                      index1 = CAN1read_canMsg( MCP_READ_RX1 );        
2235   3                              if (error & MCP_RX0IF)
2236   3                                      index = CAN1read_canMsg( MCP_READ_RX0 );        
2237   3                              if (error = CAN1readRegister(MCP_EFLG))
2238   3                              {
2239   4                                      ErrCnt++;
2240   4                                      AlterMessageByte(1,0x6E2,7,1,ErrCnt,0);
2241   4      
2242   4                                      if (error & MCP_EFLG_RX1OVR)
2243   4                                              CAN1modifyRegister(MCP_EFLG,MCP_EFLG_RX1OVR,0);
2244   4                                      if (error & MCP_EFLG_RX0OVR)
2245   4                                              CAN1modifyRegister(MCP_EFLG,MCP_EFLG_RX0OVR,0);
2246   4                              }
2247   3      
2248   3                              // clear int flags
2249   3                              IE0 = 0;                                        // clear IE0 flag re-enabling interupt
2250   3                              RxCAN1 = 0;                                     // clear my flag interupt occured
2251   3                              EX0 = 1;                                        // enable CAN1 interupt
2252   3      
2253   3                              if (index < RX1BUFFERS)                         // process recieved message from Rx0
2254   3                              {
2255   4                                      ProcessRx(1,index);             // CAN1 messages
2256   4                              }
2257   3                              if (index1 < RX1BUFFERS)                        // process recieved message from Rx1
2258   3                              {
2259   4                                      ProcessRx(1,index1);
2260   4                              }
2261   3                      }
2262   2      
2263   2                      if (StartTicks + ONESEC < msticks )     // every second
2264   2                      {
2265   3                              StartTicks = msticks;
2266   3                              LED1 ^= 1;
2267   3      
2268   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
2269   3                              if (index1 < TXBUFFS)                           // empty one time available
2270   3                              {
2271   4                                      OneTime[index1].cdat[0] = (U8)(keys>>24);
2272   4                                      OneTime[index1].cdat[1] = (U8)(keys>>16);
2273   4                                      OneTime[index1].cdat[2] = (U8)(keys>>8);
2274   4                                      OneTime[index1].cdat[3] = (U8)keys;
2275   4                                      OneTime[index1].cdat[4] = CAN1readStatus();
2276   4                                      OneTime[index1].cdat[5] = CAN1readRxStat();
2277   4                                      OneTime[index1].cdat[6] = CAN1readRegister(MCP_CANSTAT);
2278   4                                      OneTime[index1].cdat[7] = CAN1readRegister(MCP_CANINTF);
2279   4                                      AlterMessageByte(0,0x6EA,0,OneTime[index1].cdat,8,1);
2280   4                              }
2281   3      
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 38  

2282   3                              // VIN
2283   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
2284   3                              if (index1 < TXBUFFS)                           // empty one time available
2285   3                              {
2286   4                                      switch (vin++)
2287   4                                      {
2288   5                                              case 0:
2289   5                                                      OneTime[index1].cdat[0] = 0;
2290   5                                                      for (index = 0 ; index < 7 ; index++)
2291   5                                                              OneTime[index1].cdat[1+index] = VIN[index];
2292   5                                                      break;
2293   5                                              case 1:
2294   5                                                      OneTime[index1].cdat[0] = 1;
2295   5                                                      for (index = 7 ; index < 14 ; index++)
2296   5                                                              OneTime[index1].cdat[index-6] = VIN[index];
2297   5                                                      break;
2298   5                                              case 2:
2299   5                                                      OneTime[index1].cdat[0] = 2;
2300   5                                                      for (index = 14 ; index < 17 ; index++)
2301   5                                                              OneTime[index1].cdat[index-13] = VIN[index];
2302   5                                                      vin = 0;
2303   5                                                      break;
2304   5                                      }
2305   4                                      AlterMessageByte(0,0x3E0,0,OneTime[index1].cdat,8,0);
2306   4                              }
2307   3      
2308   3                              if (counter++ >= 9)     // test every 10 seconds alter 6E2 message
2309   3                              {
2310   4                                      for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
2311   4                                      if (index1 < TXBUFFS)                           // empty one time available
2312   4                                      {
2313   5                                              OneTime[index1].cdat[0] = cnt++;
2314   5                                              AlterMessageByte(1,0x6E2,6,OneTime[index1].cdat,1,2);
2315   5                                              counter = 0;
2316   5                                      }
2317   4                              }
2318   3                      }
2319   2      
2320   2      
2321   2                      if (RelayChange)
2322   2                              CheckRelay();
2323   2      
2324   2                      // check for buttons pressed and process
2325   2                      if (keyChange & 0xFFFFF00)      // At least one Buttons changed state
2326   2                      {
2327   3                              CheckButts();                   // SimpleButton Check
2328   3      
2329   3                              keyChange &= (U32)((BUTTONMASK<<8) & 0xFF);     // clear unused buttons
2330   3                      }
2331   2      
2332   2      
2333   2                      if (keyChange & 0xF0)           // Ignition change
2334   2                      {
2335   3                              // check if a relay is set to Ignition change
2336   3                              for (index1 = 0 ; index1 < 4; index1++){
2337   4                                      if ((RelayCnf[index1] & 0xF00) == REL_IGN)      // Relay controled by IGN select
2338   4                                      {
2339   5                                              if ((RelayCnf[index1]&0xFF) == ((keys>>4)&0xF)) // matching Select
2340   5                                                      RelayChange |= 1<<index1;                       // flag for relay "on" change
2341   5                                              else
2342   5                                                      RelayChange |= 0x10<<index1;            // flag for relay "off" change
2343   5                                      }
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 39  

2344   4                              }
2345   3      
2346   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
2347   3                              if (index1 < TXBUFFS)                           // empty one time available
2348   3                              {
2349   4                                      IGN_OFF = 0;                    // default IGN_OFF flag to off
2350   4                                      switch(keys & 0xF0)
2351   4                                      {
2352   5                                              case 0x10:      // IGN_OFF
2353   5                                                      // ID 190, alter byte 0,1 
2354   5                                                      OneTime[index1].cdat[0] = 0x00;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2355   5                                                      OneTime[index1].cdat[1] = 0x01;                 //key in ignition
2356   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2357   5      
2358   5                                                      // ID 98, alter bytes 2,3  
2359   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
2360   5                                                      OneTime[index1].cdat[1] = 0x0;
2361   5                                                      OneTime[index1].cdat[2] = 0x0;
2362   5                                                      OneTime[index1].cdat[3] = 0x0;
2363   5                                                      OneTime[index1].cdat[4] = 0x0;                  // 0 speed                      
2364   5                                                      OneTime[index1].cdat[5] = 0x0;
2365   5                                                      OneTime[index1].cdat[6] = 0x0;
2366   5                                                      OneTime[index1].cdat[7] = 0x0;
2367   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,8,0);
2368   5                                                      IGN_OFF = 1;    // TURN on IGN_OFF flag
2369   5                                                      IGN_OFF_FLG = 0;
2370   5                                                      break;
2371   5                                              case 0x20:      // IGN_ACC
2372   5                                                      // ID 190, alter byte 0,1 
2373   5                                                      OneTime[index1].cdat[0] = 0x03;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2374   5                                                      OneTime[index1].cdat[1] = 0x02;                 //key in ignition
2375   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2376   5      
2377   5                                                      // ID 98, alter bytes 2,3  
2378   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
2379   5                                                      OneTime[index1].cdat[1] = 0x0;
2380   5                                                      OneTime[index1].cdat[2] = 0x0;
2381   5                                                      OneTime[index1].cdat[3] = 0x0;
2382   5                                                      OneTime[index1].cdat[4] = 0x34;                         // 0 speed                      
2383   5                                                      OneTime[index1].cdat[5] = 0x0;
2384   5                                                      OneTime[index1].cdat[6] = 0x07;
2385   5                                                      OneTime[index1].cdat[7] = 0xD0;
2386   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,8,0);
2387   5                                                      IGN_OFF_FLG = 1;
2388   5                                                      break;
2389   5      
2390   5                                              case 0x30:      // IGN_START
2391   5                                                      // ID 190, alter byte 0,1 
2392   5                                                      OneTime[index1].cdat[0] = 0x05;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2393   5                                                      OneTime[index1].cdat[1] = 0x02;                 //key in ignition
2394   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2395   5      
2396   5                                                      // ID 98, alter bytes 2,3  
2397   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
2398   5                                                      OneTime[index1].cdat[1] = 0x0;
2399   5                                                      OneTime[index1].cdat[2] = 0x0;
2400   5                                                      OneTime[index1].cdat[3] = 0x0;
2401   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,4,0);
2402   5                                                      IGN_OFF_FLG = 1;
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 40  

2403   5                                                      break;
2404   5                                              case 0x40:      // IGN_RUN_0
2405   5                                                      // ID 190, alter byte 0,1 
2406   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2407   5                                                      OneTime[index1].cdat[1] = 0x02;                 //key in ignition
2408   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2409   5      
2410   5                                                      // ID 98, alter bytes 2,3  
2411   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
2412   5                                                      OneTime[index1].cdat[1] = 0x0;
2413   5                                                      OneTime[index1].cdat[2] = 0x0;
2414   5                                                      OneTime[index1].cdat[3] = 0x0;
2415   5                                                      OneTime[index1].cdat[4] = 0x34;                         // 0 speed                      
2416   5                                                      OneTime[index1].cdat[5] = 0x0;
2417   5                                                      OneTime[index1].cdat[6] = 0x07;
2418   5                                                      OneTime[index1].cdat[7] = 0xD0;
2419   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,8,0);
2420   5                                                      IGN_OFF_FLG = 1;
2421   5                                                      break;
2422   5                                              case 0x50:      // IGN_RUN_5
2423   5                                              // ID 190, alter byte 0,1 
2424   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2425   5                                                      OneTime[index1].cdat[1] = 0x02;                 //key in ignition
2426   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2427   5      
2428   5                                                      // ID 98, alter bytes 2,3  
2429   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
2430   5                                                      OneTime[index1].cdat[1] = 0x0;
2431   5                                                      OneTime[index1].cdat[2] = 0x04;
2432   5                                                      OneTime[index1].cdat[3] = 0x06;
2433   5                                                      OneTime[index1].cdat[4] = 0x34;                         // 0 speed                      
2434   5                                                      OneTime[index1].cdat[5] = 0x0;
2435   5                                                      OneTime[index1].cdat[6] = 0x07;
2436   5                                                      OneTime[index1].cdat[7] = 0xD0;
2437   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,8,0);
2438   5                                                      IGN_OFF_FLG = 1;
2439   5                                                      break;
2440   5                                              case 0x60:      // IGN_RUN_10
2441   5                                              // ID 190, alter byte 0,1 
2442   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2443   5                                                      OneTime[index1].cdat[1] = 0x02;                 //key in ignition
2444   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2445   5      
2446   5                                                      // ID 98, alter bytes 2,3  
2447   5                                                      OneTime[index1].cdat[0] = 0x0;                                          
2448   5                                                      OneTime[index1].cdat[1] = 0x0;
2449   5                                                      OneTime[index1].cdat[2] = 0x08;
2450   5                                                      OneTime[index1].cdat[3] = 0x0C;
2451   5                                                      OneTime[index1].cdat[4] = 0x34;                                         
2452   5                                                      OneTime[index1].cdat[5] = 0x0;
2453   5                                                      OneTime[index1].cdat[6] = 0x07;
2454   5                                                      OneTime[index1].cdat[7] = 0xD0;
2455   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,8,0);
2456   5                                                      IGN_OFF_FLG = 1;
2457   5                                                      break;
2458   5                                              
2459   5                                              case 0x70:
2460   5                                                      break;
2461   5                                              case 0x80:
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 41  

2462   5                                                      break;
2463   5                                      }
2464   4      
2465   4                              keyChange &= ~0xF0;             // clear Ignition nibble
2466   4                              }
2467   3                      }
2468   2                      
2469   2              }
2470   1      }
2471          void User3()    // program select 3
2472          {       
2473   1              U8 cnt=0;
2474   1      
2475   1              while(!(keyChange & 0xF))
2476   1              {
2477   2                      for (cnt = 0 ; cnt < 6 ; cnt++)
2478   2                      {
2479   3                              LED1 ^= 1;
2480   3                              mSecDelay(100);
2481   3                      }
2482   2              mSecDelay(1400);
2483   2              }
2484   1      }
2485          void User4()    // program select 4
2486          {       
2487   1              U8 cnt=0;
2488   1      
2489   1              while(!(keyChange & 0xF))
2490   1              {
2491   2                      for (cnt = 0 ; cnt < 8 ; cnt++)
2492   2                      {
2493   3                              LED1 ^= 1;
2494   3                              mSecDelay(100);
2495   3                      }
2496   2              mSecDelay(1200);
2497   2              }
2498   1      }
2499          void User5()    // program select 5
2500          {       
2501   1              U8 cnt=0;
2502   1      
2503   1              while(!(keyChange & 0xF))
2504   1              {
2505   2                      for (cnt = 0 ; cnt < 10 ; cnt++)
2506   2                      {
2507   3                              LED1 ^= 1;
2508   3                              mSecDelay(100);
2509   3                      }
2510   2              mSecDelay(1000);
2511   2              }
2512   1      }
2513          void User6()    // program select 6
2514          {       
2515   1              U8 cnt=0;
2516   1      
2517   1              while(!(keyChange & 0xF))
2518   1              {
2519   2                      for (cnt = 0 ; cnt < 12 ; cnt++)
2520   2                      {
2521   3                              LED1 ^= 1;
2522   3                              mSecDelay(100);
2523   3                      }
C51 COMPILER V9.51   USER                                                                  06/13/2016 10:09:30 PAGE 42  

2524   2              mSecDelay(800);
2525   2              }
2526   1      }
2527          void User7()    // program select 7
2528          {       
2529   1              U8 cnt=0;
2530   1      
2531   1              while(!(keyChange & 0xF))
2532   1              {
2533   2                      for (cnt = 0 ; cnt < 14 ; cnt++)
2534   2                      {
2535   3                              LED1 ^= 1;
2536   3                              mSecDelay(100);
2537   3                      }
2538   2              mSecDelay(600);
2539   2              }
2540   1      }
2541          
2542          void User8(void)        // example program select 8
2543          {
2544   1      }
2545          
2546          
2547          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  13393    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      61
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
